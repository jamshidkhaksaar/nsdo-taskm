---
description: react
globs: 
---
Accessibility: focuses on building accessible websites. Supports ARIA attributes (kebab-case). Use semantic HTML. Use React Fragments. Accessible Forms: Label form controls with htmlFor (JSX). Notify users of errors. Focus Control: Ensure keyboard operability. Use Refs to manage focus (this.textInput.current.focus()). Mouse and pointer events: Ensure functionality via keyboard (onBlur, onFocus). More Complex Widgets: ARIA Roles, States, and Properties. Development and Testing Tools: eslint-plugin-jsx-a11y. Browser accessibility audits (aXe, WAVE). Screen readers (NVDA, VoiceOver, JAWS, ChromeVox). Add React to a website using script tags. Add a DOM container (div with unique id). Load React and ReactDOM from CDN. Create a React component and render it into the container. JSX can be used with Babel (standalone or preprocessor). Minify JavaScript for production. React and ReactDOM are available over a CDN. Production versions are also available. The crossorigin attribute is recommended. Verify CDN sets Access-Control-Allow-Origin: * HTTP header. Code-Splitting: Creating multiple bundles dynamically loaded at runtime. import(): Dynamically load modules. Returns a Promise. Example: import("./math").then(math => console.log(math.add(16, 26))); React.lazy: Renders a dynamic import as a regular component. const MyComponent = React.lazy(() => import('./MyComponent')); Suspense: Show fallback content while waiting for the lazy component to load. <Suspense fallback={<div>Loading...</div>}> <MyComponent /> </Suspense> Error Boundaries: Handle loading errors with Error Boundaries. Route-based code splitting: Splitting at routes using React Router. Named Exports: Use an intermediate module to re-export named exports as default. Components: JavaScript functions/ES6 classes that accept 'props' (properties) and return React elements. Function Components: function Welcome(props) { return Hello, {props.name}; } Class Components: class Welcome extends React.Component { render() { return Hello, {this.props.name}; } } Components can be composed within other components. Props are read-only; components must not modify them. Composition vs Inheritance: Use composition (children prop, multiple "holes") to reuse code. Containment: Components use the children prop to pass arbitrary children. Specialization: More specific components render more generic ones, configuring them with props. Inheritance: Not recommended; use composition and props for flexibility. Conditional Rendering. Use JavaScript conditions for rendering. UserGreeting(), GuestGreeting(), Greeting(props): renders based on props.isLoggedIn. LoginButton(props), LogoutButton(props): buttons with onClick. LoginControl: stateful, manages login, renders Greeting, Login/LogoutButton. Mailbox(props): conditional message count. WarningBanner(props): conditional warning, returns null to prevent render. Page: manages warning state. Inline if: && operator. Inline if-else: ? : operator. Prevent render: return null in render(). Context API: Share data through component tree without prop drilling. React.createContext(defaultValue): Creates Context object. Context.Provider: Component to provide context value. Props: value. Class.contextType = MyContext: Consume context in classes via this.context. Context.Consumer: Consume context in functions with render prop, child function (value => ReactNode). Context.displayName: For DevTools display. Create React App: create a new single-page app. Next.js: for server-rendered applications. Gatsby: for static websites. Create React App: npx create-react-app my-app. Toolchains: package manager, bundler, compiler. DOM Elements: React DOM properties & attributes are camelCased (tabIndex). Exceptions: aria-*, data-* (lowercased). Attributes differences: checked (controlled component, defaultChecked uncontrolled), className (CSS class, class for Web Components), dangerouslySetInnerHTML ({__html: markup} for innerHTML, risky for XSS), htmlFor (for "for" attribute), onChange (form field changes), selected (option in select value), style ({camelCased: value}, not autoprefixed, vendor prefixes with capital), suppressContentEditableWarning, suppressHydrationWarning, value (controlled, defaultValue uncontrolled). All standard/custom DOM attributes supported. SVG attributes also supported. Custom attributes lowercase. Error boundaries catch JavaScript errors in child component trees, display fallback UI. Use static getDerivedStateFromError() to render fallback UI. Use componentDidCatch() to log errors. Error boundaries do NOT catch event handler or async code errors. Uncaught errors unmount the component tree. Class components only. SyntheticEvent: A cross-browser wrapper around the browser's native event. stopPropagation(): void, preventDefault(): void, persist(): void Attributes: bubbles: boolean, cancelable: boolean, currentTarget: DOMEventTarget, defaultPrevented: boolean, eventPhase: number, isTrusted: boolean, nativeEvent: DOMEvent, target: DOMEventTarget, timeStamp: number, type: string Supported Events: Clipboard Events: onCopy, onCut, onPaste. Properties: clipboardData: DOMDataTransfer Composition Events: onCompositionEnd, onCompositionStart, onCompositionUpdate. Properties: data: string Keyboard Events: onKeyDown, onKeyPress, onKeyUp. Properties: altKey: boolean, charCode: number, ctrlKey: boolean, getModifierState(key): string, key: string, keyCode: number, locale: string, location: number, metaKey: boolean, repeat: boolean, shiftKey: boolean, which: number Focus Events: onFocus, onBlur. Properties: relatedTarget: DOMEventTarget Form Events: onChange, onInput, onInvalid, onReset, onSubmit Generic Events: onError, onLoad Mouse Events: onClick, onContextMenu, onDoubleClick, onDrag, onDragEnd, onDragEnter, onDragExit, onDragLeave, onDragOver, onDragStart, onDrop, onMouseDown, onMouseEnter, onMouseLeave, onMouseMove, onMouseOut, onMouseOver, onMouseUp. Properties: altKey: boolean, button: number, buttons: number, clientX: number, clientY: number, ctrlKey: boolean, getModifierState(key): boolean, metaKey: boolean, pageX: number, pageY: number, relatedTarget: DOMEventTarget, screenX: number, screenY: number, shiftKey: boolean Pointer Events: onPointerDown, onPointerMove, onPointerUp, onPointerCancel, onGotPointerCapture, onLostPointerCapture, onPointerEnter, onPointerLeave, onPointerOver, onPointerOut. Extends Mouse Events. Properties: pointerId: number, width: number, height: number, pressure: number, tangentialPressure: number, tiltX: number, tiltY: number, twist: number, pointerType: string, isPrimary: boolean Selection Events: onSelect Touch Events: onTouchCancel, onTouchEnd, onTouchMove, onTouchStart. Properties: altKey: boolean, changedTouches: DOMTouchList, ctrlKey: boolean, getModifierState(key): boolean, metaKey: boolean, shiftKey: boolean, targetTouches: DOMTouchList, touches: DOMTouchList UI Events: onScroll. Properties: detail: number, view: DOMAbstractView Wheel Events: onWheel. Properties: deltaMode: number, deltaX: number, deltaY: number, deltaZ: number Media Events: onAbort, onCanPlay, onCanPlayThrough, onDurationChange, onEmptied, onEncrypted, onEnded, onError, onLoadedData, onLoadedMetadata, onLoadStart, onPause, onPlay, onPlaying, onProgress, onRateChange, onSeeked, onSeeking, onStalled, onSuspend, onTimeUpdate, onVolumeChange, onWaiting Image Events: onLoad, onError Animation Events: onAnimationStart, onAnimationEnd, onAnimationIteration. Properties: animationName: string, pseudoElement: string, elapsedTime: float Transition Events: onTransitionEnd. Properties: propertyName: string, pseudoElement: string, elapsedTime: float Other Events: onToggle AJAX and APIs. Use AJAX libraries (Axios, fetch). AJAX in componentDidMount. componentDidMount(): fetch data, setState. useEffect(() => {}, []): hooks equivalent. MyComponent: state {error, isLoaded, items}. Handles error, loading, and displays items. JSX is optional. ES6 is optional. Comments in JSX: <div>{/*Comment*/}</div> Passing Functions to Components: Pass event handlers as props to child components. Binding: Use bind in constructor, class properties (experimental), or arrow functions in render to ensure functions have access to component attributes. Avoid calling functions in render; pass references. Parameter Passing: Use arrow functions or bind to pass parameters to event handlers. Rate Limiting: Use throttling, debouncing (lodash), or requestAnimationFrame to control function execution frequency. Virtual DOM is a programming concept where a virtual representation of a UI is kept in memory and synced with the real DOM by a library like ReactDOM. Reconciliation updates the real DOM to match the virtual DOM. React elements and Fibers are parts of the virtual DOM implementation. Shadow DOM is a browser technology for scoping; Virtual DOM is a JavaScript concept. setState(): Schedules an update to the component's state object, causing re-rendering. props: Passed to the component. state: Managed within the component. setState() is asynchronous in event handlers. Update state based on current state using a function: this.setState((state) => {return {count: state.count + 1}}). Avoid relying on synchronous updates to this.state after calling setState(). Consider state management libraries (Redux, MobX) for complex applications. File Structure. React project structure recommendations. Group by features/routes or file type. Avoid deep nesting. Colocate related files. Styling and CSS. Add CSS classes with className prop: <span className="class-name">. Inline styles supported. CSS classes better for performance than inline styles. CSS-in-JS: pattern via third-party libraries. Animations: React Transition Group, React Motion, React Spring, Framer Motion. React follows semantic versioning. x.y.z: z for critical bug fixes, y for new features/non-critical fixes, x for breaking changes. Breaking changes are minimized. Development builds include warnings for future breaking changes. Forms: Controlled components use React state as single source of truth for form values. NameForm: class component, state:{value:string}, handleChange(event), handleSubmit(event), render(): form with text input. EssayForm: class component, state:{value:string}, handleChange(event), handleSubmit(event), render(): form with textarea. FlavorForm: class component, state:{value:string}, handleChange(event), handleSubmit(event), render(): form with select. Reservation: class component, state:{isGoing:boolean, numberOfGuests:number}, handleInputChange(event), render(): form with checkbox and number input. Forwarding Refs: Passing a ref through a component to a child. React.forwardRef((props, ref) => ReactNode): Creates a component that forwards a ref to its child. - props: Component props. - ref: Ref to be forwarded. - Returns: React node. React.createRef(): Creates a ref object. HOCs and Refs: Refs are not passed through HOCs by default. Use React.forwardRef to forward refs in HOCs. DevTools Display Name: Use render function name or displayName to customize DevTools display name. Fragments: Group children without adding DOM nodes. Usage: <React.Fragment> <Child /> </React.Fragment> Short syntax: <> <Child /> <>. Short syntax does not support keys or attributes. <React.Fragment key={item.id}> supports keys for mapping collections. React is a JavaScript library for building user interfaces. Start with tutorial or main concepts guide. Use online playgrounds. Add React to a website or create a new React app. JavaScript knowledge is assumed. Use MDN and javascript.info for JavaScript help. Single-page Application: loads a single HTML page. ES6/ES2015/ES2016: recent ECMAScript versions. Compilers: transform JavaScript code (e.g., Babel). Bundlers: combine JavaScript/CSS modules (e.g., Webpack). Package Managers: manage dependencies (e.g., npm, Yarn). CDN: delivers cached content. JSX: syntax extension to JavaScript, compiled to React.createElement(). Elements: building blocks of React applications, immutable. Components: reusable code returning a React element. props: inputs to a React component, readonly. props.children: content between component tags. state: data managed by the component itself. Lifecycle Methods: custom functionality during component phases. Controlled vs. Uncontrolled Components: React controls form inputs. Keys: unique string attribute for array elements. Refs: special attribute for direct DOM access. Events: event handlers in camelCase. Reconciliation: comparing and updating DOM. React event handling: camelCase event names (onClick), function handlers. e.preventDefault() for default prevention. Synthetic events: cross-browser. Class handlers: bind this. Pass arguments: arrow functions or bind. Higher-Order Components (HOC): function taking component, returning enhanced component for logic reuse. Use for cross-cutting concerns. Example: const EnhancedComponent = higherOrderComponent(WrappedComponent). withSubscription(WrappedComponent, selectData): example HOC for data subscription. Convention: pass unrelated props. Convention: composability via single-argument HOCs e.g. compose(HOC1, HOC2)(Component). Convention: wrap display name for debugging e.g. WithSubscription(ComponentName). Caveats: Don't use HOCs in render (remounting). Static methods not copied; use hoist-non-react-statics or export separately. Refs not passed; use React.forwardRef. Building Your Own Hooks: Custom Hooks are functions whose names start with "use" and may call other Hooks. UseFriendStatus example: function useFriendStatus(friendID) { const [isOnline, setIsOnline] = useState(null); useEffect(() => { ... }); return isOnline; } Custom Hooks are for stateful logic reuse, each call isolated. Pass information between hooks (e.g., useFriendStatus(recipientID)). useEffect(effect, [dependencies]): Performs side effects in function components after render. Replaces componentDidMount, componentDidUpdate, componentWillUnmount. useEffect(() => { document.title = `You clicked ${count} times`; }, [count]); effect: Function containing side effect logic. dependencies: Optional array of dependency values. Effect runs if dependencies change. Empty array [] runs effect only on mount/unmount. If deps are omitted, effect runs after every render. Returning a function from effect cleans up after it. React cleans up previous render effects before running next effects. Use multiple useEffect calls to separate concerns. useLayoutEffect: Synchronous API identical to useEffect, blocks browser updates. Hooks FAQ. Hooks in React 16.8+ for state and features without classes. No class rewrite needed, use Hooks in new code. Hooks for component logic reuse. Hooks use existing React concepts. Classes and Hooks can be mixed. Hooks aim to cover class use cases, some not yet. Hooks simpler than render props/HOCs. Redux connect(), React Router work with Hooks. Hooks work with static typing. Test Hooks components like regular ones. ESLint plugin enforces Hook rules. Lifecycle to Hooks: constructor->useState, getDerivedStateFromProps->render update, shouldComponentUpdate->React.memo, render->function body, componentDidMount/Update/WillUnmount->useEffect. Data fetch with Hooks. useRef() for instance variables. useState for state. Effects run after render useEffect(callback, [dependencies]). Dependency array for effect updates, [] for mount only. useCallback for memoized callbacks. useMemo for memoized values. useReducer for state management. Context for prop drilling alternative. Hooks optimized, closures efficient, useCallback, useMemo for perf. useEventCallback (advanced) for event handlers. Hooks internals: memory cells. Hooks prior art: functional APIs, render props, algebraic effects. Hooks: Use state and React features in functional components. import React, { useState } from 'react'; Example: function Example() { const [count, setCount] = useState(0); return ( <div> <p>Clicked {count} times</p> <button onClick={() => setCount(count + 1)}>Click</button> </div> ); } Opt-in, backwards-compatible. Hooks don't replace React concepts. Motivation: share stateful logic, simplify complex components, avoid classes. Hooks (React 16.8+): functions for state/features in function components. useState(initialState): state/setter. useEffect(effectFn, dependencies?): side effects, cleanup. Rules: top level calls, in function components/custom hooks. Custom Hooks: reuse logic ("use" prefix). useContext, useReducer: other built-in Hooks. Hooks: Enable state and React features in function components. useState: const [state, setState] = useState(initialState). Returns stateful value and function to update it. setState enqueues re-render. Functional updates: setState(prevState => newState). Lazy init: useState(() => initialState). useEffect(didUpdate, [dependencies]): Executes code after render. Can return cleanup function. Default: runs after every render. Conditional: runs when dependencies change. useEffect(() => {}, []): runs once (mount/unmount). useContext(MyContext): Returns context value for context object. Triggers re-render on context change. useReducer(reducer, initialArg, init): Alternative to useState. Returns state and dispatch method. Lazy init: useReducer(reducer, initialArg, init). useCallback(() => {doSomething(a, b)}, [a, b]): Returns memoized callback. Changes only if dependencies change. useMemo(() => computeExpensiveValue(a, b), [a, b]): Returns memoized value. Recomputes only when dependencies change. useRef(initialValue): Returns mutable ref object (.current property). Persists for component lifetime. useImperativeHandle(ref, createHandle, [deps]): Customizes instance value exposed to parent components with ref. Requires forwardRef. useLayoutEffect: Like useEffect, but synchronous after DOM mutations. Use for reading layout and re-rendering. useDebugValue(value, formatter): Displays label for custom hooks in React DevTools. Rules of Hooks: 1. Only Call Hooks at the Top Level: Donâ€™t call Hooks inside loops, conditions, or nested functions. 2. Only Call Hooks from React Functions: Call Hooks from React function components or custom Hooks. ESLint plugin: eslint-plugin-react-hooks enforces these rules. Rules ensure Hooks are called in same order each render, preserving state. Order matters for useState and useEffect. Conditional Hooks can cause bugs due to order shift. Solution: put conditions inside Hooks. Custom Hooks reuse stateful logic. useState(initialState): [currentState, setStateFunction]. Hook for function components to declare state variables. Returns current state and function to update it. Example: const [count, setCount] = useState(0); React integration with DOM libraries. Avoid DOM conflicts. Wrap plugins in components. Class SomePlugin: componentDidMount(), componentWillUnmount(), render(): empty div - jQuery plugin wrapper. Class Chosen extends React.Component: render(): div select, componentDidMount(): init chosen, componentWillUnmount(): destroy, componentDidUpdate(prevProps): trigger update, handleChange(e): props.onChange - Chosen wrapper. ReactDOM.render: embed React. Function Button, HelloButton, Paragraph - component examples. Class ParagraphView extends Backbone.View: render(): ReactDOM.render Paragraph, remove(): ReactDOM.unmountComponentAtNode - Backbone view. Class Item extends React.Component: handleChange(): forceUpdate, componentDidMount(): listen 'change', componentWillUnmount(): unlisten, render(): li model.text - Backbone model item. Class List extends React.Component: handleChange(): forceUpdate, componentDidMount(): listen 'add'/'remove', componentWillUnmount(): unlisten, render(): ul Item list - Backbone collection list. Function connectToBackboneModel(WrappedComponent): HOC, constructor(props): state=model.attributes, componentDidMount(): listen 'change', componentWillReceiveProps(nextProps): update state, componentWillUnmount(): unlisten, handleChange(model): setState model.changedAttributes(), render(): WrappedComponent - connect Backbone model. Function NameInput, BackboneNameInput, Example - Backbone HOC usage. Use lifecycle methods, refs for integration. JSX produces React elements. Expressions are embedded in curly braces. Attributes use quotes for strings and curly braces for expressions. className (JSX) corresponds to class (HTML). JSX prevents injection attacks. JSX compiles to React.createElement(). React 16 requires Map and Set. Use core-js for older browsers. Requires requestAnimationFrame (use raf package). JSX is syntactic sugar for React.createElement(component, props, ...children). Capitalized types refer to React components. React must be in scope. Components starting with lowercase letters refer to built-in HTML elements. Props: JavaScript expressions, string literals (HTML unescaped), boolean (defaults to true), spread attributes. Children: string literals, JSX elements, JavaScript expressions, functions. Booleans, null, undefined are ignored. Legacy Context (deprecated): Context API for passing data through component trees. Button.contextTypes: defines context types. MessageList.childContextTypes, getChildContext(): provides context. Function components can also reference context with contextTypes. Do not update context directly, trigger a local state update. Event Pooling (React 16 and earlier): SyntheticEvent objects are pooled and reused. Properties nulled after handler. e.persist() prevents object reuse for async access. Lifting State Up: Share state between components by moving it to their closest common ancestor. BoilingVerdict(props): func component, props:{celsius:number}, renders text if water boils. Calculator: class component, state:{temperature:string, scale:'c'|'f'}, handleChange(e), render(): manages temp inputs, renders TemperatureInput(c), TemperatureInput(f), BoilingVerdict. TemperatureInput(props): class component, props:{scale:'c'|'f', temperature:string, onTemperatureChange:func}, handleChange(e), render(): input for temperature. toCelsius(fahrenheit): func, converts F to C. toFahrenheit(celsius): func, converts C to F. tryConvert(temperature, convert): func, converts temp string, handles invalid input. Transform lists with map(). Keys identify list items. Key should be unique among siblings, often data IDs. Indexes as keys are discouraged if order changes. Extract components, keep key on the array. Example: <li key={number.toString()}>{number}</li> Optimizing Performance: 1. Production Build: use minified production build (npm run build Create React App). 2. Profiling: React DevTools Profiler (react-dom/profiling production bundle). 3. Virtualize Long Lists: windowing (react-window, react-virtualized) for large lists. 4. Avoid Reconciliation: shouldComponentUpdate(nextProps, nextState) (skip re-render if returns false), React.PureComponent (shallow prop/state comparison). Immutable Data: avoid mutating props/state for PureComponent. Use concat, spread syntax, Object.assign, object spread for immutable updates. Immer, immutability-helper for complex objects. Portals: ReactDOM.createPortal(child, container). Renders child into DOM node outside parent hierarchy. Usage: break out of overflow: hidden, z-index containers (dialogs, tooltips). Event Bubbling: portal behaves like normal React child in React tree for context and event bubbling, regardless of DOM position. Event from portal propagates to React ancestors. Profiler API measures React app render frequency and cost. Identify slow parts for optimization. Disabled in production. Usage: <Profiler id="name" onRender={callback}> <Component/> </Profiler>. onRender(id, phase, actualDuration, baseDuration, startTime, commitTime, interactions) callback for render updates. id: profiler id. phase: "mount" or "update". actualDuration: render time. baseDuration: estimated worst-case render time. startTime: render start timestamp. commitTime: render commit timestamp. interactions: traced interactions. React: Entry point to the React library. Components: React.Component: Base class for React components. class Greeting extends React.Component { render() { return <h1>Hello, {this.props.name}</h1>; } } React.PureComponent: Implements shouldComponentUpdate() with shallow prop/state comparison. React.memo: HOC, memoizes result, skips rendering if props are the same. React.memo(MyComponent, areEqual); Creating Elements: createElement(type, [props], [...children]): Creates React element. cloneElement(element, [config], [...children]): Clones element, shallowly merges props. createFactory(type): Returns function that produces React elements. Legacy. Transforming Elements: isValidElement(object): Checks if object is a React element. React.Children: map(children, function[(thisArg)]), forEach(children, function[(thisArg)]), count(children), only(children), toArray(children) React.Fragment: Returns multiple elements without wrapper. <></> Refs: createRef(): Creates ref. forwardRef(fn): Forwards ref to child component. const FancyButton = React.forwardRef((props, ref) => (<button ref={ref}>{props.children}</button>)); Suspense: lazy(import): Loads components dynamically. <React.Suspense fallback={<Spinner />}><OtherComponent /></React.Suspense> Hooks: useState, useEffect, useContext, useReducer, useCallback, useMemo, useRef, useImperativeHandle, useLayoutEffect, useDebugValue React.Component: Define components as classes. Required method: render(). Lifecycle methods (optional): Mounting: constructor(), static getDerivedStateFromProps(), render(), componentDidMount(). Updating: static getDerivedStateFromProps(), shouldComponentUpdate(), render(), getSnapshotBeforeUpdate(), componentDidUpdate(). Unmounting: componentWillUnmount(). Error Handling: static getDerivedStateFromError(), componentDidCatch(). Other APIs: setState(), forceUpdate(). Class Properties: defaultProps, displayName. Instance Properties: props, state. render(): Returns React elements, arrays, fragments, portals, strings, numbers, booleans, or null. Should be pure. constructor(props): Called before mounting. Call super(props) first. Used for initializing state and binding event handlers. Do not call setState() here. componentDidMount(): Called after component is mounted. Use to set up subscriptions or load data. Can call setState() immediately. componentDidUpdate(prevProps, prevState, snapshot): Called after updating. Use to operate on the DOM and make network requests. Can call setState() conditionally. componentWillUnmount(): Called before unmounting. Perform cleanup here. Do not call setState(). shouldComponentUpdate(nextProps, nextState): Optimizes re-rendering; defaults to true. Not called for initial render or forceUpdate(). Return false to skip update. Avoid deep equality checks. static getDerivedStateFromProps(props, state): Returns an object to update state or null. Invoked before render on mount and updates. getSnapshotBeforeUpdate(prevProps, prevState): Captures DOM info before potential changes. Returns a value passed to componentDidUpdate(). Error Boundaries: static getDerivedStateFromError(error): Returns state to update on error. Called during render phase. componentDidCatch(error, info): Logs errors. Called during commit phase. Legacy Lifecycle Methods: UNSAFE_componentWillMount(), UNSAFE_componentWillReceiveProps(nextProps), UNSAFE_componentWillUpdate(nextProps, nextState). setState(updater, [callback]): Enqueues state changes. Asynchronous. Updater function: (state, props) => stateChange. callback executed after update. setState(stateChange[, callback]): Shallow merge. forceUpdate(callback): Forces re-render, skipping shouldComponentUpdate(). defaultProps: Default prop values for the class. displayName: For debugging messages. props: Props from the caller. state: Component-specific data that can change over time. Do not mutate this.state directly. ReactDOM provides DOM-specific methods. render(element, container, callback): Renders a React element into the DOM. hydrate(element, container, callback): Renders a container whose HTML contents were rendered by ReactDOMServer. unmountComponentAtNode(container): Removes a mounted React component from the DOM. Returns boolean. findDOMNode(component): Returns the native browser DOM element. createPortal(child, container): Creates a portal. ReactDOMServer: Renders components to static markup, typically used on a Node server. Methods: renderToString(element): Renders a React element to its initial HTML. Returns an HTML string. renderToStaticMarkup(element): Similar to renderToString, but doesn't create extra DOM attributes used internally by React. renderToNodeStream(element): Renders a React element to its initial HTML. Returns a Readable stream that outputs an HTML string. Server-only. renderToStaticNodeStream(element): Similar to renderToNodeStream, but doesn't create extra DOM attributes used internally by React. Server-only. React Without ES6: Using create-react-class instead of ES6 classes. createReactClass(spec): Creates a React component class. getDefaultProps(): Defines default props (instead of static defaultProps). getInitialState(): Defines initial state (instead of constructor). Autobinding: createReactClass autobinds methods, ES6 classes require explicit .bind(this). Mixins: createReactClass supports mixins (legacy). No mixin support for ES6 classes. var Greeting = createReactClass({ render: function() { return <h1>Hello, {this.props.name}</h1>; } }); React Without JSX. JSX is optional. React.createElement(component, props, ...children): JSX sugar. component: string, React.Component subclass, or function. Shorthand: const e = React.createElement. Reconciliation. React diffing algorithm for UI updates. O(n) heuristic. Assumptions: different types -> different trees, key prop for stable children. Diffing: compare root elements. Different types: rebuild tree. Same type (DOM): update attributes. Same type (Component): update props, lifecycle methods, recurse render(). Recursing children: iterate, mutate. key prop: efficient reordering. Keys unique among siblings, avoid index for reordering. Tradeoffs: implementation detail, heuristics-based, stable keys important. Refs access DOM nodes or React elements imperatively. Use cases: focus, text selection, media, animations, DOM libraries. Avoid for declarative solutions. React.createRef(): create ref. ref attribute: attach ref to element. ref.current: access node/instance. DOM Element Ref: ref to DOM element. Class Component Ref: ref to component instance. Function Components: no ref attribute directly, use forwardRef or convert to class. useRef hook in function components. Ref forwarding: expose child DOM ref to parent. Callback Refs: function for ref attribute, called on mount/unmount. Legacy String Refs: avoid. Caveat: inline callback refs called twice on update. React release channels: Latest, Next, Experimental. Latest: stable, semver, user applications, npm tag 'latest'. Next: prerelease, release candidate, integration testing, npm tag 'next', no semver, breaking changes possible. Experimental: prerelease, experimental features, test upcoming features, npm tag 'experimental', no semver, frequent breaking changes. Latest for production. Next/Experimental for testing only. Next for integration tests. Experimental for early feature access. Versions: Latest (semver), Next/Experimental (hash+date). React Elements are smallest UI building blocks, plain immutable objects updated by ReactDOM.render(). ReactDOM.render(element, container) renders element into DOM node. React DOM efficiently updates only changed parts. Render Props: Share code between React components via a prop whose value is a function. The function returns a React element and is called instead of implementing its own render logic. Example: <DataProvider render={data => (<h1>Hello {data.target}</h1> )}/> withMouse(Component): Creates a HOC using a render prop. Caveats: Using render props with React.PureComponent may negate its advantage if the render prop is created inside a render method. State and Lifecycle. State is private, component-controlled data. Class components: extend React.Component, use render(). State initialization in constructor with this.state = {}. Access state with this.state. Lifecycle methods: componentDidMount() after render, componentWillUnmount() before unmount. setState({newState}) for updating state, triggers re-render, updates are merged, may be asynchronous, function form setState((prevState, props) => ({})). Data flows down from parent to children. Stateless/stateful components implementation detail. Flow: static type checker for JavaScript. Requires: flow-bin, @babel/preset-flow (if not using Create React App). TypeScript: typed superset of JavaScript. Requires: typescript. File extensions: .ts, .tsx (JSX). Create React App: supports TypeScript out of the box. Declaration files: provide type information. ReScript: typed language compiling to JavaScript. Kotlin: statically typed language for React. StrictMode component: tool for identifying potential issues in development only. Checks: unsafe lifecycles, string refs, findDOMNode, side effects, legacy context API. No UI in production. Jest is a JavaScript test runner that lets you access the DOM via js-dom. It is a JS test runner. Jest provides great iteration speed combined with features like mocking modules and timers. React Testing Library helps test React components without relying on implementation details. Testing Environments: Test runners: Jest, mocha, ava. Jest: Widely compatible, mocked modules, timers, jsdom. Mocking a rendering surface: Simulate browser with jsdom. Mocking functions: Mock functions with test-friendly versions for data fetching. Mocking modules: Mock modules with suitable replacements. Mocking timers: Mock timers to manually advance time. End-to-end tests: Test longer workflows with Cypress, Playwright, Puppeteer. Testing Recipes: Common patterns for testing React components with Jest. act(function): From react-dom/test-utils. Ensures all updates are processed before assertions. Rendering: Test component renders correctly with props. Example: render(<Hello name="Jenny" />, container); expect(container.textContent).toBe("Hello, Jenny!"); Data Fetching: Mock API requests with dummy data. jest.spyOn(global, "fetch").mockImplementation(() => ...); global.fetch.mockRestore(); Mocking Modules: Mock dependencies with dummy components. jest.mock("./map", () => ...); Events: Dispatch DOM events on elements. button.dispatchEvent(new MouseEvent("click", { bubbles: true })); Timers: Use Jest's timer mocks. jest.useFakeTimers(); jest.advanceTimersByTime(5000); jest.useRealTimers(); Snapshot Testing: Save rendered component output with toMatchSnapshot/toMatchInlineSnapshot. Use sparingly. TestRenderer: Renders React components to pure JavaScript objects. TestRenderer.create(element, options): Creates TestRenderer instance. Returns instance. options: createNodeMock. TestRenderer.act(callback): Prepares component for assertions. Wraps create and update calls. testRenderer.toJSON(): Returns object representing rendered tree (platform-specific nodes/props). testRenderer.toTree(): Returns object representing rendered tree (includes user-written components). testRenderer.update(element): Re-renders in-memory tree. Simulates React update. testRenderer.unmount(): Unmounts in-memory tree. testRenderer.getInstance(): Returns root element instance, if available. testRenderer.root: Returns root "test instance" object. testInstance.find(test): Finds single descendant test instance where test(testInstance) is true. Throws if not exactly one. testInstance.findByType(type): Finds single descendant test instance with type. Throws if not exactly one. testInstance.findByProps(props): Finds single descendant test instance with props. Throws if not exactly one. testInstance.findAll(test): Finds all descendant test instances where test(testInstance) is true. testInstance.findAllByType(type): Finds all descendant test instances with type. testInstance.findAllByProps(props): Finds all descendant test instances with props. testInstance.instance: Component instance for class components. testInstance.type: Component type. testInstance.props: Component props. testInstance.parent: Parent test instance. testInstance.children: Children test instances. ReactTestUtils: Testing utilities for React components. act(callback): Prepares a component for assertions. mockComponent(componentClass, [mockTagName]): Mocks a component with a simple div (or mockTagName). Use jest.mock() instead. isElement(element): Returns true if element is a React element. isElementOfType(element, componentClass): Returns true if element is a React element of type componentClass. isDOMComponent(instance): Returns true if instance is a DOM component (e.g., div, span). isCompositeComponent(instance): Returns true if instance is a user-defined component. isCompositeComponentWithType(instance, componentClass): Returns true if instance is a component of type componentClass. findAllInRenderedTree(tree, test): Traverses tree, accumulating components where test(component) is true. scryRenderedDOMComponentsWithClass(tree, className): Finds all DOM elements with class className. findRenderedDOMComponentWithClass(tree, className): Like scryRenderedDOMComponentsWithClass, expects one result. Throws if not one. scryRenderedDOMComponentsWithTag(tree, tagName): Finds all DOM elements with tag tagName. findRenderedDOMComponentWithTag(tree, tagName): Like scryRenderedDOMComponentsWithTag, expects one result. Throws if not one. scryRenderedComponentsWithType(tree, componentClass): Finds all instances of components with type componentClass. findRenderedComponentWithType(tree, componentClass): Same as scryRenderedComponentsWithType, expects one result. Throws if not one. renderIntoDocument(element): Renders element into detached DOM node. Requires window, document. Simulate.{eventName}(element, [eventData]): Simulates event dispatch on DOM node. Thinking in React: Guide to building web apps with React. Steps: 1. Break UI into a component hierarchy. 2. Build a static version in React, using props for data flow. 3. Identify the minimal representation of UI state. 4. Identify where your state should live. 5. Add inverse data flow (handle user input). PropTypes for typechecking component props. PropTypes: array, bool, func, number, object, string, symbol, node, element, elementType, instanceOf, oneOf, oneOfType, arrayOf, objectOf, shape, exact, any, isRequired, custom validator, defaultProps. Example: Greeting.propTypes = {name: PropTypes.string}. Default prop values: Greeting.defaultProps = { name: 'Stranger' }. Uncontrolled Components: Form data handled by the DOM. Use refs to get form values. React.createRef(): Creates a ref to access DOM nodes. handleSubmit(event): Handles form submission; access values via ref.current.value. event.preventDefault(). defaultValue: Specifies initial value, subsequent updates uncontrolled. <input defaultValue="Bob" type="text" ref={this.input} /> defaultChecked: For checkboxes and radio buttons. defaultValue: For select and textarea. File input tag: <input type="file" /> is always uncontrolled. Use File API to interact with files. fileInput.current.files[0].name: Access selected file name. React and Web Components solve different problems. Use Web Components in React by accessing imperative APIs with refs or by writing React wrapper components. Events emitted by a Web Component may not propagate through a React render tree requiring manual handling. Web Components use "class" instead of "className". Example: <brick-flipbox class="demo"> React in Web Components example: class XSearch extends HTMLElement { connectedCallback() { ReactDOM.render(<a href={url}>{name}</a>, mountPoint); } } customElements.define('x-search', XSearch); Fix Babel transformation with custom-elements-es5-adapter.
