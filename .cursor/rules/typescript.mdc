---
description: typescript
globs: 
---
Types: string, number, bigint, boolean, symbol, null, undefined, object, unknown, never. Function: function fn(x) { return x.flip(); } greet(person: string, date: Date): console.log(`Hello ${person}, today is ${date.toDateString()}!`); tsc --noEmitOnError hello.ts (prevents .js output on error) Classes in TypeScript support ES2015 class syntax with type annotations. Class Members include Fields, Constructors, Methods, Getters/Setters, and Index Signatures. Fields: `class Point { x: number; y: number; }` declares public properties; optional type annotation; initializers allowed; `readonly` modifier. Constructors: `constructor(x = 0, y = 0)` similar to functions, no return type, call `super()` in derived classes. Methods: `scale(n: number): void` function properties with type annotations, access via `this`. Getters/Setters: `get prop(){}`, `set prop(v){}` accessors, readonly if only getter. Index Signatures: `[s: string]: type` for object-like indexing. Class Heritage: `implements Interface`, `extends BaseClass`. implements checks interface conformance. extends for inheritance. Overriding Methods: derived class methods can override base class methods, use `super.method()` to call base. Type-only Field Declarations: `declare field: Type` for type re-declaration without runtime effect. Member Visibility: `public` (default), `protected` (subclasses), `private` (within class). JavaScript private fields `#field` for hard privacy. Static Members: `static member`, class-level members, visibility modifiers, inherited. Static Blocks: `static {}` for initialization code. Generic Classes: `class Box{}`, type parameters, constraints, defaults. this in Classes: `this` context in methods. Arrow Functions: `method = () => {}` bind `this` lexically. this parameters: `method(this: MyClass){}` enforce `this` type. this Types: `method(): this` return type as current class type. this-based type guards: `method(): this is Type`. Parameter Properties: `constructor(public field: type)`. Class Expressions: `const MyClass = class{}`. Constructor Signatures: `InstanceType`. Abstract Classes: `abstract class Base{ abstract method(); }`, cannot be instantiated, subclasses must implement abstract members. Abstract Construct Signatures: `function greet(ctor: new()=>Base){}`. Class relationships are structural. Conditional Types: `T extends U ? X : Y`. Choose type based on condition. Useful with generics. NameOrId: `T extends number ? IdLabel : NameLabel`. Example of conditional type. createLabel(idOrName: T): NameOrId. Function using conditional type. MessageOf: `T extends { message: unknown } ? T["message"] : never`. Extracts property type or never if missing. Flatten: `T extends any[] ? T[number] : T`. Flattens arrays. Infer: `T extends Array ? Item : T`. Deduce type within conditionals. GetReturnType: `T extends (...args: never[]) => infer R ? R : never`. Extracts function return type. Distributive Types: Conditional types distribute over unions. Non-Distributive: `[T] extends [any] ? T[] : never`. Prevents distribution. Everyday Types: string, number, boolean; Array: number[]; any; Type Annotations: let myName: string = "Alice"; Functions: function greet(name: string); function getFavoriteNumber(): number; Function returning Promise: async function getFavoriteNumber(): Promise<number>; Object Types: function printCoord(pt: { x: number; y: number }); Optional Properties: function printName(obj: { first: string; last?: string }); Union Types: function printId(id: number | string); type Point = { x: number; y: number; }; Interfaces: interface Point { x: number; y: number; } Type Assertions: const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement; Literal Types: function printText(s: string, alignment: "left" | "right" | "center"); null and undefined; Enums; bigint; symbol. Functions: basic building blocks. Function Type Expressions: (param: type) => returnType; describes function type. Example: (a: string) => void. Parameter name required but type optional (defaults to any). Type alias for function type: type FuncName = (param: type) => returnType. Call Signatures: describe callable objects with properties. Syntax: { description: string; (arg: type): returnType; }. Construct Signatures: describe constructor functions with 'new' keyword. Syntax: { new (arg: type): returnType; }. Can combine call and construct signatures in interfaces. Generic Functions: type parameters for relating input/output types. Example: function firstElement(arr: Type[]): Type | undefined. Type Inference: TypeScript automatically infers type parameters. Constraints: limit type parameters using 'extends'. Example: . Working with Constrained Values: ensure function returns same type as input, not just constraint type. Specifying Type Arguments: manually specify type parameters: functionCall(...). Guidelines for Generics: Push type parameters down, use fewer parameters, type parameters should appear twice. Optional Parameters: param?: type or param = defaultValue. Type becomes type | undefined. Optional Parameters in Callbacks: avoid optional callback parameters unless intended for function to be called without the argument. Function Overloads: multiple function signatures for different argument types/counts. Overload signatures followed by implementation signature. Implementation signature not directly callable. Overload signatures must be compatible with implementation. Prefer union types over overloads when possible. 'this' in Functions: declare 'this' type as first parameter in function body for explicit 'this' context. Use 'function' keyword, not arrow functions. void: return type for functions without explicit return value. Not same as undefined. object: non-primitive type. Not Object or {}. unknown: any value, but unsafe to use directly. Safer than any. never: functions that never return, throw error or terminate. Function: global type for all functions, unsafe any return type, avoid if possible, use () => void instead. Rest Parameters: ...param: type[]; allows variable number of arguments. Rest Arguments: ...array; spread syntax to pass array as multiple arguments. Parameter Destructuring: unpack object arguments. Syntax: function sum({ a, b }: { a: number; b: number }). Assignability of Functions: void return type in contextual typing allows functions to return values which are ignored, except for literal function definitions with void return type, which must not return anything. Generics: Create reusable components working over a variety of types. function identity(arg: Type): Type: Returns the argument. Type is a type variable. let output = identity("myString"); Explicitly set Type. let output = identity("myString"); Type argument inference. function loggingIdentity(arg: Type[]): Type[]: Operates on arrays of Type. interface GenericIdentityFn { (arg: Type): Type; }: Generic interface. interface GenericIdentityFn { (arg: Type): Type; }: Generic type as parameter of interface. class GenericNumber { zeroValue: NumType; add: (x: NumType, y: NumType) => NumType; }: Generic class. Instance side is generic, not static. interface Lengthwise { length: number; }: Interface for constraint. function loggingIdentity(arg: Type): Type: Constrains function to types with .length. function getProperty(obj: Type, key: Key): Gets property from object. function create(c: { new (): Type }): Type: Creates instances. declare function create( element?: T, children?: U ): Container: Creates HTMLElement. interface Producer { make(): T; }: Covariance example. interface Consumer { consume: (arg: T) => void; }: Contravariance example. interface ProducerConsumer { consume: (arg: T) => void; make(): T; }: Invariant annotation example. Indexed Access Types: Lookup property types using indexing. type Person = {age: number; name: string; alive: boolean}; type Age = Person["age"]; Supports unions: Person["age" | "name"], keyof: Person[keyof Person]. Example with array: const MyArray = [{name: "Alice", age: 15}]; type Person = typeof MyArray[number]; type Age = Person["age"]; keyof operator: Takes object type, returns string or numeric literal union of keys. type Point = { x: number; y: number }; type P = keyof Point; // P is "x" | "y". String/number index signature returns those types. type Arrayish = { [n: number]: unknown }; type A = keyof Arrayish; type Mapish = { [k: string]: boolean }; type M = keyof Mapish; M is string | number. Useful with mapped types. Mapped Types: Generic types using keyof. OptionsFlags: Properties to boolean. Modifiers: readonly, ? (+/- prefixes). CreateMutable: -readonly. Concrete: -?. Key Remapping: 'as' clause. Getters: get prefix. RemoveKindField: Exclude keys. EventConfig: map unions. ExtractPII: checks pii:true. Modules: Files with top-level import/export. Executed within own scope. Non-modules (scripts): Files without import/export, in global scope. ES Module Syntax: export default function helloWorld() { ... } import helloWorld from "./hello.js"; export var pi = 3.14; import { pi } from "./maths.js"; import { pi as Ï€ } from "./maths.js"; import * as math from "./maths.js"; console.log(math.pi); import type { Cat } from "./animal.js"; CommonJS Syntax: module.exports = { pi: 3.14, absolute }; const maths = require("./maths"); maths.pi; esModuleInterop: Compiler flag for CommonJS/ES Modules interop. Module Resolution: Classic, Node. Affects how module names map to files. Module Output Options: target (JS features), module (module loader). ES2020, CommonJS, UMD. TypeScript namespaces: Legacy module format, use ES Modules instead. Narrowing: Refines types based on control flow. typeof guards: "string", "number", "bigint", "boolean", "symbol", "undefined", "object", "function". Truthiness narrowing: Values coerce to false: 0, NaN, "", 0n, null, undefined. Equality narrowing: ===, !==, ==, !=. in operator: "value" in x. instanceof narrowing: x instanceof Foo. Assignments: Type narrowed on assignment. Control flow analysis: Analyzes code for reachability. Type predicates: function isFish(pet: Fish | Bird): pet is Fish { return (pet as Fish).swim !== undefined; }. Assertion functions. Discriminated unions: type Shape = Circle | Square;. never type: Represents unreachable states. Exhaustiveness checking: Use never in default case for switch statements. Object Types: Represent data grouping. Anonymous: function greet(person: { name: string; age: number }) { ... }. Interface: interface Person { name: string; age: number; }. Type Alias: type Person = { name: string; age: number; }. Optional Properties: interface PaintOptions { shape: Shape; xPos?: number; yPos?: number; }. Readonly Properties: interface SomeType { readonly prop: string; }. Index Signatures: Describe types of possible values when property names are unknown. interface StringArray { [index: number]: string; }. Excess Property Checks: Validate object more thoroughly when created/assigned. interface SquareConfig { color?: string; width?: number; [propName: string]: unknown; }. Extending Types: interface AddressWithUnit extends BasicAddress { unit: string; }. Intersection Types: Combine existing object types. type ColorfulCircle = Colorful & Circle;. Generic Object Types: interface Box<Type> { contents: Type; }. Array Type: Array<number> or number[]. ReadonlyArray Type: readonly string[]. Tuple Types: type StringNumberPair = [string, number]; Tuple types can have optional elements: type Either2dOr3d = [number, number, number?]; readonly Tuple Types: function doSomething(pair: readonly [string, number]) { ... }. Template Literal Types: type World = "world"; type Greeting = \`hello \${World}\`; type EmailLocaleIDs = "welcome_email" | "email_heading"; type FooterLocaleIDs = "footer_title" | "footer_sendoff"; type AllLocaleIDs = \`\${EmailLocaleIDs | FooterLocaleIDs}\_id\`; type Lang = "en" | "ja" | "pt"; type LocaleMessageIDs = \`\${Lang}\_\${AllLocaleIDs}\`; type PropEventSource<Type> = { on(eventName: \`\${string & keyof Type}Changed\`, callback: (newValue: any) => void): void; }; declare function makeWatchedObject<Type>(obj: Type): Type & PropEventSource<Type>; type PropEventSource<Type> = { on<Key extends string & keyof Type> (eventName: \`\${Key}Changed\`, callback: (newValue: Type[Key]) => void): void; }; type Uppercase<StringType>: converts to uppercase; type Lowercase<StringType>: converts to lowercase; type Capitalize<StringType>: capitalizes first letter; type Uncapitalize<StringType>: uncapitalizes first letter. typeof: operator to get type of variable or property. ReturnType: gets return type of a function. Limitations: typeof only on identifiers/properties. Creating Types from Types. Generics: Types which take parameters. Keyof Type Operator: Using keyof to create new types. Typeof Type Operator: Using typeof to create new types. Indexed Access Types: Type['a'] syntax. Conditional Types: Types act like if statements. Mapped Types: Creating types by mapping properties. Template Literal Types: Mapped types change properties via template literal strings. Install ASP.NET Core and TypeScript. Create a new ASP.NET Core Web Application project. Configure Startup.cs: `app.UseDefaultFiles(); app.UseStaticFiles();`. Add a scripts folder and app.ts file. Example app.ts: `function sayHello() { ... return `Hello from ...!`; }`. Configure tsconfig.json: `{ "compilerOptions": { "noEmitOnError": true, "noImplicitAny": true, "sourceMap": true, "target": "es6" }, "files": ["./app.ts"], "compileOnSave": true }`. Set up NPM with package.json (add gulp, del to devDependencies). Set up gulpfile.js: `gulp.task("clean", function () { return del(["wwwroot/scripts/**/*"]); }); gulp.task("default", function (done) { gulp.src(paths.scripts).pipe(gulp.dest("wwwroot/scripts")); done(); });`. Add index.html with script reference. Run project to test. Debug in browser's debugger tab. Babel vs tsc: Use tsc if build output == source input. Use Babel for transpiling and tsc for type checking if multiple outputs needed. Babel for transpiling, tsc for types: Babel's preset-typescript for JS, tsc for type checking/d.ts. TSC with: "declaration": true, "emitDeclarationOnly": true, "isolatedModules": true. Basic Types: boolean: true/false values. number: Floating point numbers, BigIntegers, supports hex, decimal, binary, octal. bigint: For large integers. string: Textual data, single/double quotes, template strings. array: `number[]` or `Array`. tuple: Fixed size array, known types e.g. `[string, number]`. enum: Named numeric values, default 0, can be set. unknown: Type-safe any, must narrow type before use. any: Bypasses type checking, use sparingly. void: No return value for functions. null: Represents null. undefined: Represents undefined. never: For functions that always error or loop. object: Non-primitive type. Type Assertion: `as string` or ``. Number, String, Boolean, Symbol, Object: Avoid these, use lowercase primitives. TypeScript Cheat Sheets: Syntax reference pages for TypeScript code. Classes: class ClassName { }. Constructor: constructor(params). Methods: methodName(params): returnType. Inheritance: class Derived extends Base { super(baseParams); }. Modifiers: public (default), private (internal), protected (internal+subclass). ECMAScript private fields: #fieldName. readonly: readonly propertyName. Parameter properties: constructor(modifier param: type). Accessors: get propertyName() { }, set propertyName(value) { }. Static Properties: static propertyName. Abstract Classes: abstract class AbstractClass { abstract abstractMethod(); }. Cannot instantiate abstract classes directly. Constructor functions: class name is also a type. Class can be used as interface. Compiler Options: Flags and Types for TypeScript compilation. CLI Commands: --all: Show all options. --help: Show help. --init: Initialize tsconfig.json. --listFilesOnly: List files. --locale: Set language. --project: Compile project. --showConfig: Print config. --version: Print version. Build Options: --build: Build projects. --clean: Delete outputs. --dry: Show build. --force: Build all. --verbose: Enable verbose logging. Watch Options: --excludeDirectories: Remove directories. --excludeFiles: Remove files. --fallbackPolling: Polling method. --synchronousWatchDirectory: Sync directory watchers. --watch: Watch files. --watchDirectory: Directory watch method. --watchFile: File watch method. Compiler Flags (Examples): --allowArbitraryExtensions: Allow extensions. --allowImportingTsExtensions: Allow .ts extensions in imports. --allowJs: Allow JavaScript files. --allowSyntheticDefaultImports: Allow default imports. --allowUmdGlobalAccess: Allow UMD globals. --allowUnreachableCode: Disable unreachable code errors. --allowUnusedLabels: Disable unused label errors. --alwaysStrict: Always emit 'use strict'. --assumeChangesOnlyAffectDirectDependencies: Affect dependencies. --baseUrl: Base directory for module resolution. --checkJs: Enable JavaScript error reporting. --composite: Enable project references. --customConditions: Conditions for resolving imports. --declaration: Generate .d.ts files. --declarationDir: Output directory for .d.ts files. --declarationMap: Create sourcemaps for .d.ts files. --diagnostics: Output compiler performance. --disableReferencedProjectLoad: Reduce project loading. --disableSizeLimit: Remove JavaScript file size cap. --disableSolutionSearching: Opt out of project checking. --disableSourceOfProjectReferenceRedirect: Disable source files. --downlevelIteration: Emit verbose JavaScript for iteration. --emitBOM: Emit UTF-8 BOM. --emitDeclarationOnly: Output only .d.ts files. --emitDecoratorMetadata: Emit decorator metadata. --esModuleInterop: Emit JavaScript for CommonJS interop. --exactOptionalPropertyTypes: Interpret optional types. --experimentalDecorators: Enable experimental decorators. --explainFiles: Print included files. --extendedDiagnostics: Output compiler performance details. --forceConsistentCasingInFileNames: Ensure casing in imports. --generateCpuProfile: Emit CPU profile. --generateTrace: Generates an event trace. --importHelpers: Import helper functions from tslib. --importsNotUsedAsValues: Specify emit/checking behavior for imports. --incremental: Save .tsbuildinfo files. --inlineSourceMap: Include sourcemaps. --inlineSources: Include source code in sourcemaps. --isolatedDeclarations: Require annotation on exports. --isolatedModules: Ensure files can be transpiled safely. --jsx: JSX code generation. --jsxFactory: JSX factory function. --jsxFragmentFactory: JSX fragment reference. --jsxImportSource: Module specifier for JSX functions. --keyofStringsOnly: keyof returns strings only. --lib: Specify library declaration files. --listEmittedFiles: Print emitted files. --listFiles: Print files read during compilation. --mapRoot: Debugger map file location. --maxNodeModuleJsDepth: Max depth for checking JavaScript files. --module: Module code generation. --moduleDetection: File type detection method. --moduleResolution: Module resolution strategy. --moduleSuffixes: Suffixes to search when resolving a module. --newLine: Newline character. --noCheck: Disable full type checking. --noEmit: Disable emitting files. --noEmitHelpers: Disable helper function generation. --noEmitOnError: Disable emitting on errors. --noErrorTruncation: Disable truncating types in errors. --noFallthroughCasesInSwitch: Report fallthrough cases. --noImplicitAny: Report implicit any type errors. --noImplicitOverride: Require override modifier. --noImplicitReturns: Report missing return statements. --noImplicitThis: Report this type errors. --noImplicitUseStrict: Disable 'use strict'. --noLib: Disable including library files. --noPropertyAccessFromIndexSignature: Use indexed accessors. --noResolve: Disallow imports. --noStrictGenericChecks: Disable generic checks. --noUncheckedIndexedAccess: Add undefined to index access. --noUncheckedSideEffectImports: Check side effect imports. --noUnusedLocals: Report unused local variables. --noUnusedParameters: Report unused parameters. --out: Deprecated. Use outFile. --outDir: Output folder. --outFile: Bundle output file. --paths: Remap imports. --plugins: Specify language service plugins. --preserveConstEnums: Disable erasing const enums. --preserveSymlinks: Disable resolving symlinks. --preserveValueImports: Preserve unused imports. --preserveWatchOutput: Disable console wiping. --pretty: Enable color and formatting. --reactNamespace: React object for createElement. --removeComments: Disable emitting comments. --resolveJsonModule: Enable importing .json files. --resolvePackageJsonExports: Use package.json 'exports'. --resolvePackageJsonImports: Use package.json 'imports'. --rootDir: Root folder. --rootDirs: Treat multiple folders as one. --skipDefaultLibCheck: Skip default .d.ts type checking. --skipLibCheck: Skip all .d.ts type checking. --sourceMap: Create source map files. --sourceRoot: Root path for debuggers. --stopBuildOnErrors: Skip building downstream projects on error. --strict: Enable all strict type-checking options. --strictBindCallApply: Check bind/call/apply arguments. --strictBuiltinIteratorReturn: Iterator return type. --strictFunctionTypes: Check function assignment types. --strictNullChecks: Check null and undefined. --strictPropertyInitialization: Check uninitialized class properties. --stripInternal: Disable emitting @internal declarations. --suppressExcessPropertyErrors: Disable excess property errors. --suppressImplicitAnyIndexErrors: Suppress noImplicitAny index errors. --target: JavaScript language version. --traceResolution: Log moduleResolution paths. --tsBuildInfoFile: Store .tsbuildinfo file path. --typeRoots: Specify multiple folders for @types. --types: Specify type package names. --useDefineForClassFields: Emit ECMAScript-standard class fields. --useUnknownInCatchVariables: Default catch clause variables as unknown. --verbatimModuleSyntax: Do not transform imports/exports. MSBuild + TypeScript: Configure via tsconfig.json (recommended) or project settings (.csproj). Project settings via PropertyGroups. <TypeScriptNoEmitOnError>true</TypeScriptNoEmitOnError>. CLI Mappings: <TypeScriptAllowJS> --allowJs. <TypeScriptRemoveComments> --removeComments. <TypeScriptNoImplicitAny> --noImplicitAny. <TypeScriptGeneratesDeclarations> --declaration. <TypeScriptModuleKind> --module. <TypeScriptJSXEmit> --jsx. <TypeScriptOutDir> --outDir. <TypeScriptSourceMap> --sourcemap. <TypeScriptTarget> --target. <TypeScriptNoResolve> --noResolve. <TypeScriptMapRoot> --mapRoot. <TypeScriptSourceRoot> --sourceRoot. <TypeScriptEmitBOM> --emitBOM. <TypeScriptNoLib> --noLib. <TypeScriptPreserveConstEnums> --preserveConstEnums. <TypeScriptSuppressImplicitAnyIndexErrors> --suppressImplicitAnyIndexErrors. <TypeScriptNoEmitHelpers> --noEmitHelpers. <TypeScriptInlineSourceMap> --inlineSourceMap. <TypeScriptInlineSources> --inlineSources. <TypeScriptNewLine> --newLine. <TypeScriptIsolatedModules> --isolatedModules. <TypeScriptEmitDecoratorMetadata> --emitDecoratorMetadata. <TypeScriptRootDir> --rootDir. <TypeScriptExperimentalDecorators> --experimentalDecorators. <TypeScriptModuleResolution> --moduleResolution. <TypeScriptSuppressExcessPropertyErrors> --suppressExcessPropertyErrors. <TypeScriptReactNamespace> --reactNamespace. <TypeScriptSkipDefaultLibCheck> --skipDefaultLibCheck. <TypeScriptAllowUnusedLabels> --allowUnusedLabels. <TypeScriptNoImplicitReturns> --noImplicitReturns. <TypeScriptNoFallthroughCasesInSwitch> --noFallthroughCasesInSwitch. <TypeScriptAllowUnreachableCode> --allowUnreachableCode. <TypeScriptForceConsistentCasingInFileNames> --forceConsistentCasingInFileNames. <TypeScriptAllowSyntheticDefaultImports> --allowSyntheticDefaultImports. <TypeScriptNoImplicitUseStrict> --noImplicitUseStrict. <TypeScriptLib> --lib. <TypeScriptBaseUrl> --baseUrl. <TypeScriptDeclarationDir> --declarationDir. <TypeScriptNoImplicitThis> --noImplicitThis. <TypeScriptSkipLibCheck> --skipLibCheck. <TypeScriptStrictNullChecks> --strictNullChecks. <TypeScriptNoUnusedLocals> --noUnusedLocals. <TypeScriptNoUnusedParameters> --noUnusedParameters. <TypeScriptAlwaysStrict> --alwaysStrict. <TypeScriptImportHelpers> --importHelpers. <TypeScriptJSXFactory> --jsxFactory. <TypeScriptStripInternal> --stripInternal. <TypeScriptCheckJs> --checkJs. <TypeScriptDownlevelIteration> --downlevelIteration. <TypeScriptStrict> --strict. <TypeScriptNoStrictGenericChecks> --noStrictGenericChecks. <TypeScriptPreserveSymlinks> --preserveSymlinks. <TypeScriptStrictFunctionTypes> --strictFunctionTypes. <TypeScriptStrictPropertyInitialization> --strictPropertyInitialization. <TypeScriptESModuleInterop> --esModuleInterop. <TypeScriptEmitDeclarationOnly> --emitDeclarationOnly. <TypeScriptKeyofStringsOnly> --keyofStringsOnly. <TypeScriptUseDefineForClassFields> --useDefineForClassFields. <TypeScriptDeclarationMap> --declarationMap. <TypeScriptResolveJsonModule> --resolveJsonModule. <TypeScriptStrictBindCallApply> --strictBindCallApply. <TypeScriptNoEmitOnError> --noEmitOnError. TypeScriptAdditionalFlags: custom CLI flags. Debug/Release: PropertyGroup conditions. TypeScriptToolsVersion: compiler version. TypeScriptCompileBlocked: disable build in VS. TypeScriptEnableIncrementalMSBuild: disable incremental MSBuild. Configuring Watch. TypeScript compiler watch configuration in tsconfig.json watchOptions or environment variables. fs.watch (events) or fs.watchFile (polling) for file watching. fs.watch unreliable, OS dependent, CPU light. fs.watchFile reliable, CPU heavy. watchOptions in tsconfig.json: { "watchOptions": { "watchFile": "useFsEvents"|"useFsEventsWithFallbackDynamicPolling"|"priorityPollingInterval"|"dynamicPriorityPolling"|"useFsEventsOnParentDirectory", "watchDirectory": "useFsEvents"|"recursiveDirectoryUsingFsWatchFile"|"recursiveDirectoryUsingDynamicPriorityPolling", "fallbackPolling": "dynamicPriority"|"fixedInterval", "synchronousWatchDirectory": true|false, "excludeDirectories": string[], "excludeFiles": string[] } }. Environment variables: TSC_WATCHFILE (PriorityPollingInterval, DynamicPriorityPolling, UseFsEvents, UseFsEventsWithFallbackDynamicPolling, UseFsEventsOnParentDirectory, default: UseFsEventsOnParentDirectory if TSC_NONPOLLING_WATCHER=true else fs.watchFile 250ms), TSC_WATCHDIRECTORY (RecursiveDirectoryUsingFsWatchFile, RecursiveDirectoryUsingDynamicPriorityPolling, default: UseFsEvents). declare namespace: Defines types/values accessed by dot notation. declare function: Declares a function. declare var: Declares a variable. declare const: Declares a read-only variable. declare let: Declares a block-scoped variable. interface: Defines a type with properties. type alias: Creates a shorthand for a type. declare class: Describes a class or class-like object. Consumption: Use npm to download type declarations: npm install --save-dev @types/lodash. If the npm package includes a declaration file, downloading @types is unnecessary. Import: import * as _ from "lodash"; or use global variable _. Search: Type declaration packages are named @types/package-name. Contribute if a declaration file is missing. Declaration File Theory: Structuring modules for API shape. Types: type, interface, class, enum, import. Values: let, const, var, namespace, module, enum, class, import, function. Namespaces: Types can exist in namespaces. Combinations: One name, multiple meanings (type, value, namespace). class C {}: Creates type C (instance shape) and value C (constructor function). interface Foo { x: number; } interface Foo { y: number; } // Merges: Foo has x and y. namespace C { export let x: number; } // Adds static member to class C. namespace X { export interface Y {} export class Z {} } // Can merge different declarations. Do's and Don'ts: Types: Use number, string, boolean, symbol. Avoid Number, String, Boolean, Symbol, Object. Use object instead of Object. Generics: Avoid generics without using type parameter. any: Avoid unless migrating JavaScript. Use unknown when type unknown. Callbacks: Use void return for callbacks whose value ignored. Avoid optional parameters in callbacks unless truly optional. Overloads and Callbacks: Avoid separate overloads differing only on callback arity. Use single overload with max arity. Function Overloads Ordering: Specific overloads after general ones. Optional Parameters: Use optional parameters instead of overloads differing in trailing parameters. Union Types: Use union types instead of overloads differing by type in one argument position. Generate .d.ts files from JavaScript using JSDoc. Steps: Add TypeScript, add tsconfig.json, run compiler, edit package.json. tsconfig.json options: allowJs, declaration, emitDeclarationOnly, outDir, declarationMap. package.json: types field points to the .d.ts file. Introduction: Guide to writing TypeScript Declaration Files (.d.ts). Familiarity with TypeScript types and modules is required. Modules .d.ts shows how to type an npm package with no types. Declaration Reference: Common API patterns and declarations. Library Structures: Understand library formats and declaration files. Template: Use declaration files as a starting point. Doâ€™s and Donâ€™ts: Avoid common errors. Deep Dive: Advanced declaration writing concepts. Publishing: Publish declaration files to npm. Consumption: Locate and install declaration files. Declaration files describe JavaScript libraries. Types: Modular, Global, UMD. Modular: import/export, require. Global: Accessed globally, no import. UMD: Module or global. Templates: module.d.ts, module-class.d.ts, module-function.d.ts, module-plugin.d.ts, global.d.ts. Dependencies: /// , import statements. Publishing declaration files to npm: Bundle with package or publish to @types. Include declarations in npm package: Set "types" property in package.json to declaration file. { "name": "awesome", "main": "./lib/main.js", "types": "./lib/main.d.ts" } Dependencies: Use "dependencies" for declaration packages. Red flags: Use /// <reference types="..." /> instead of /// <reference path="..." />. Packaging dependent declarations: Depend on npm type declaration package if needed. typesVersions: Allows version-specific type resolutions. { "name": "package-name", "types": "./index.d.ts", "typesVersions": { ">=3.1": { "*": ["ts3.1/*"] } } } Folder redirects: Use "*" for path mapping. File redirects: Specify exact filenames for resolution changes. Matching behavior: Uses Node's semver ranges. Order matters for overlapping ranges. Publish to @types: Submit a pull request to DefinitelyTyped. Templates: global-modifying-module.d.ts, global-plugin.d.ts, global.d.ts, module-class.d.ts, module-function.d.ts, module-plugin.d.ts, module.d.ts Global Libraries: Accessible from global scope without imports. Template: declare function myLib(a: string): string; declare namespace myLib { let timeout: number; class Cat { constructor(n: number); purr(): void; } interface CatSettings { weight: number; name: string; } type VetID = string | number; function checkCat(c: Cat, s?: VetID); } Global-modifying Modules: Alters existing global scope values when imported. Declare global { interface String { fancyFormat(opts: StringFormatOptions): string; } }. Export types/values as usual. Use export {}; if module exports nothing. Global Plugin UMD. UMD modules usable as module or global. Detect UMD: check typeof define, typeof window, typeof module. Module plugins change shape of another module. Global plugins change shape of some global. Global-modifying modules alter global scope on import. Use /// <reference types="..." /> for global lib dependencies. Use import * as moment from "moment"; for module dependencies. Don't use /// <reference for UMD dependencies with modules. Declare types namespaced by global variable. Example: declare namespace cats { interface KittySettings {}}. interface Number { toBinaryString(opts?: MyLibrary.BinaryFormatOptions): string; }. declare namespace MyLibrary { type BinaryFormatCallback = (n: number) => string; interface BinaryFormatOptions { prefix?: string; padding: number; } } Module Class. Type definitions for class modules. Use index.d.ts in module folder. Import CommonJS style: import x = require('[MODULE]'); or default import with --allowSyntheticDefaultImports/--esModuleInterop: import x from '[MODULE]'. Export global variable if UMD module: export as namespace "super-greeter";. Export class: export = Greeter;. Declare class methods and properties: declare class Greeter { constructor(customGreeting?: string); greet: void; myMethod(opts: MyClass.MyClassMethodOptions): number; }. Export types in namespace: declare namespace MyClass { export interface MyClassMethodOptions { width?: number; height?: number; } } Module .d.ts: Describes exported values for JavaScript modules. CommonJS: Uses module.exports. Example: module.exports = { getArrayLength, maxInterval, }; .d.ts: export function getArrayLength(arr: any[]): number; export const maxInterval: 12;. ES Modules: export function getArrayLength(arr) { ... }. .d.ts: export function getArrayLength(arr: any[]): number;. Default Exports: Can export any value. module.exports = /hello( world)?/; declare const helloWorld: RegExp; export default helloWorld;. export default requires esModuleInterop: true or use export= syntax. export=: declare function getArrayLength(arr: any[]): number; declare namespace getArrayLength { declare const maxInterval: 12; } export = getArrayLength;. Namespaces: Used when ES Module syntax is insufficient. export class API { constructor(baseURL: string); getInfo(opts: API.InfoRequest): API.InfoResponse; }. Optional Global Usage: export as namespace moduleName;. Module Function. Type definitions for function modules. Use index.d.ts in module folder. Import CommonJS style: import x = require('[MODULE]'); or default import with --allowSyntheticDefaultImports/--esModuleInterop: import x from '[MODULE]'. Export global variable if UMD module: export as namespace myFuncLib;. Export function: export = Greeter;. Function overloads: declare function Greeter(name: string): Greeter.NamedReturnType; declare function Greeter(length: number): Greeter.LengthReturnType;. Export types in namespace: declare namespace Greeter { export interface LengthReturnType { width: number; height: number; } export interface NamedReturnType { firstName: string; lastName: string; } export const defaultName: string; export let defaultLength: number; } Module Plugin: Extends existing libraries. import { greeter } from "super-greeter"; export module "super-greeter" { export interface GreeterFunction { hyperGreet(): void; } } ES6 Impact: ES6 modules are immutable, plugins that modify top-level exports won't be possible. Declaration Merging: Compiler merges declarations with the same name into a single definition. Concepts: Namespace: Creates a namespace with dotted notation access. Type: Creates a type with a declared shape. Value: Creates values visible in JavaScript output. Merging Interfaces: Merges members into a single interface. Non-function members must be unique or of the same type. Function members are treated as overloads. Later declarations have higher precedence. interface Box { height: number; width: number; } interface Box { scale: number; } let box: Box = { height: 5, width: 6, scale: 10 }; Specialized signatures (single string literal type) are ordered first in overloads. Merging Namespaces: Type definitions from exported interfaces are merged. Namespace value is extended with exported members. Non-exported members are only visible in their original namespace. Merging Namespaces with Classes/Functions/Enums: Namespace declaration must follow the merged declaration. class Album { label: Album.AlbumLabel; } namespace Album { export class AlbumLabel {} } Disallowed Merges: Classes cannot merge with other classes or variables. Module Augmentation: Patches existing objects by importing and updating. declare module "./observable" { interface Observable<T> { map<U>(f: (x: T) => U): Observable<U>; } } Limitations: Cannot declare new top-level declarations or augment default exports. Global augmentation: Adds declarations to the global scope from inside a module. Decorators: Annotate/modify classes/members. Use @expression. Requires experimentalDecorators compiler option. Decorator Factories: function returning decorator expression. function color(value: string) { return function (target) { ... }; } Decorator Composition: Evaluated top-to-bottom, called bottom-to-top. Decorator Evaluation Order: Parameter, Method/Accessor/Property (instance), Parameter, Method/Accessor/Property (static), Parameter (constructor), Class. Class Decorators: Applied to class constructor. Can observe/modify/replace class definition. function sealed(constructor: Function) { Object.seal(constructor); Object.seal(constructor.prototype); } Method Decorators: Applied to Property Descriptor. Can observe/modify/replace method definition. Args: target, member name, descriptor. function enumerable(value: boolean) { return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) { descriptor.enumerable = value; }; } Accessor Decorators: Applied to Property Descriptor. Args: target, member name, descriptor. Apply to first accessor (get or set). Property Decorators: Args: target, member name. No descriptor. Used to record metadata. Parameter Decorators: Args: target, member name, parameter index. Used to observe parameter declaration. Metadata: Reflect-metadata library for metadata API. Requires emitDecoratorMetadata compiler option. import "reflect-metadata"; function validate<T>(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<T>) { ... } DOM Manipulation: HTMLElement type. TypeScript includes DOM API type definitions. HTMLElement is the backbone. Example: const app = document.getElementById("app"); const p = document.createElement("p"); p.textContent = "Hello, World!"; app?.appendChild(p); Document: Interface for global document variable. Document.getElementById(elementId: string): HTMLElement | null; Returns HTMLElement or null. Document.createElement(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K]; Creates an HTML element. Node: Base interface for HTMLElements. Node.appendChild(newChild: T): T; Appends a child node. Children vs childNodes: children returns HTMLCollection of element children. childNodes returns NodeList including text nodes. querySelector(selectors: string): Element | null; querySelectorAll(selectors: string): NodeListOf; Selects DOM elements. MDN documentation provides additional details. Download TypeScript: Install via npm, NuGet, or Visual Studio Extension. npm: npm install typescript --save-dev. Use npx tsc to compile. NuGet: Install-Package Microsoft.TypeScript.MSBuild (for MSBuild). Visual Studio Extension: Extensions > Manage Extensions. Global Installation (npm): npm install -g typescript. Transpilers: Babel, swc, Sucrase (convert TS to JS, but don't type-check). Enums: Define named constants. Numeric enums: enum Direction { Up = 1, Down, Left, Right, } String enums: enum Direction { Up = "UP", Down = "DOWN", Left = "LEFT", Right = "RIGHT", } const enums: const enum Enum { A = 1, B = A * 2, } can only use constant enum expressions and are removed during compilation. Functions: Named and anonymous functions. function add(x: number, y: number): number { return x + y; } let myAdd: (x: number, y: number) => number = function (x: number, y: number): number { return x + y; }; Optional parameters: function buildName(firstName: string, lastName?: string) { ... } lastName is optional. Optional params must follow required params. Default parameters: function buildName(firstName: string, lastName = "Smith") { ... } lastName defaults to "Smith". Rest parameters: function buildName(firstName: string, ...restOfName: string[]) { ... } Gathers arguments into an array. this: Variable set when a function is called. Arrow functions capture this where the function is created. interface Card { suit: string; card: number; } interface Deck { createCardPicker(this: Deck): () => Card; } this parameters: function f(this: void) {}. Used in callbacks. Overloads: Multiple function types for the same function. function pickCard(x: { suit: string; card: number }[]): number; function pickCard(x: number): { suit: string; card: number }; function pickCard(x: any): any { ... } Generics: Create reusable components. function identity(arg: T): T. Type variables: T. Generic types: let myIdentity: (arg: T) => T = identity;. Generic interfaces: interface GenericIdentityFn { (arg: T): T; }. Generic classes: class GenericNumber { zeroValue: T; add: (x: T, y: T) => T; }. Constraints: interface Lengthwise { length: number; }. function loggingIdentity(arg: T): T. Keyof constraints: function getProperty(obj: T, key: K): T[K]. Class Types: function create(c: { new (): T }): T { return new c(); }. Gulp: Build TypeScript; Browserify, terser, Watchify, Babelify. Requires Node.js, npm. Project structure: src/ -> TypeScript, dist/ -> output. npm init: entry point ./dist/main.js. npm install -g gulp-cli. npm install --save-dev typescript gulp@4.0.0 gulp-typescript. main.ts: function hello(compiler: string) { console.log(`Hello from ${compiler}`); } hello("TypeScript"); tsconfig.json: { "files": ["src/main.ts"], "compilerOptions": { "noImplicitAny": true, "target": "es5" } }. gulpfile.js: var gulp = require("gulp"); var ts = require("gulp-typescript"); var tsProject = ts.createProject("tsconfig.json"); gulp.task("default", function () { return tsProject.src().pipe(tsProject()).js.pipe(gulp.dest("dist")); }); gulp: runs compiler. Modules: src/greet.ts: export function sayHello(name: string) { return `Hello from ${name}`; }. Browserify: bundles modules for browser. npm install --save-dev browserify tsify vinyl-source-stream. index.html: <script src="bundle.js"></script>. main.ts: import { sayHello } from "./greet"; function showHello(divName: string, name: string) { const elt = document.getElementById(divName); elt.innerText = sayHello(name); } showHello("greeting", "TypeScript"); gulpfile.js (Browserify): var gulp = require("gulp"); var browserify = require("browserify"); var source = require("vinyl-source-stream"); var tsify = require("tsify"); var paths = { pages: ["src/*.html"], }; gulp.task("copy-html", function () { return gulp.src(paths.pages).pipe(gulp.dest("dist")); }); gulp.task( "default", gulp.series(gulp.parallel("copy-html"), function () { return browserify({ basedir: ".", debug: true, entries: ["src/main.ts"], cache: {}, packageCache: {}, }) .plugin(tsify) .bundle() .pipe(source("bundle.js")) .pipe(gulp.dest("dist")); }) ); Watchify: incremental compilation. Babel: ES2015+ to ES5/ES3. Terser: code compaction. Watchify: npm install --save-dev watchify fancy-log. Terser: npm install --save-dev gulp-terser vinyl-buffer gulp-sourcemaps. Babel: npm install --save-dev babelify@8 babel-core babel-preset-es2015 vinyl-buffer gulp-sourcemaps. Babel config in gulpfile: .transform("babelify", { presets: ["es2015"], extensions: [".ts"], }). TypeScript target ES2015. Integrating with Build Tools: Babel: npm install @babel/cli @babel/core @babel/preset-typescript --save-dev, .babelrc { "presets": ["@babel/preset-typescript"] }, CLI: ./node_modules/.bin/babel --out-file bundle.js src/index.ts, package.json { "scripts": { "build": "babel --out-file bundle.js main.ts" }, }, Browserify: npm install tsify, CLI: browserify main.ts -p [ tsify --noImplicitAny ] > bundle.js, API: browserify().add().plugin().bundle().pipe(), Grunt: grunt-ts (deprecated), grunt-browserify + tsify, Gulp: gulp-typescript, Jspm: npm install -g jspm@beta, MSBuild: update project file, NuGet: Microsoft.TypeScript.MSBuild, Rollup: @rollup/plugin-typescript, Svelte: svelte-preprocess, Vite: supports .ts, Webpack: ts-loader Interfaces define the shape of objects ("duck typing"). interface LabeledValue { label: string; }. Optional properties: interface SquareConfig { color?: string; width?: number; }. Readonly properties: interface Point { readonly x: number; readonly y: number; }. Excess Property Checks: TypeScript checks for extra properties in object literals. Function Types: interface SearchFunc { (source: string, subString: string): boolean; }. Indexable Types: interface StringArray { [index: number]: string; }. Numeric indexer must subtype string indexer. Class Types: Implementing an interface: class Clock implements ClockInterface { currentTime: Date; constructor() {}}. Interfaces describe the public side of the class. Extending Interfaces: interface Square extends Shape { sideLength: number; }. Hybrid Types: Combination of function and object. Interfaces Extending Classes: inherits members but not implementations. Only implementable by that class or subclass if private/protected members exist. TypeScript Handbook: Explains TypeScript syntax and patterns. Focuses on type errors. Key concepts: static typechecking, structural subtyping. Handbook structure: comprehensive guide, not a language specification. Reference Files: deeper explanation of concepts. Non-Goals: excludes core JavaScript basics, language specification, tool interactions. Get Started: links to introductory pages for different programming backgrounds. JS Projects Utilizing TypeScript: Type system with different strictness levels. TypeScript with JavaScript: Use editor with TypeScript plugins. Type Hints in JS via JSDoc: /** @type {number} */ var x;. @ts-check: Add to .js files for TypeScript errors. @ts-nocheck: Skip checking a file. // @ts-ignore or // @ts-expect-error: Ignore errors on specific lines. Iterators and Generators: Iterable objects implement Symbol.iterator. Iterable: Interface for iterable types. function toArray(xs: Iterable): X[] { return [...xs] }. for..of: Loops over iterable objects. for..in: Iterates over object keys. for..of: Iterates over values. let someArray = [1, "string", false]; for (let entry of someArray) { console.log(entry); } Targeting ES5: Iterators only allowed on Array type. Targeting ECMAScript 2015+: Uses built-in iterator implementation. JSDoc Reference: @type: primitive types, declared types, JSDoc @typedef, TypeScript syntax. Array types: number[], Array.<number>, Array<number>. Object literal types: { a: string, b: number }. Function types: Closure and TypeScript syntax. Casts: /** @type {number} */ (numberOrString). @param & @returns: Type syntax as @type. @typedef, @callback, and @param: Define complex types. @template: Generic types. @satisfies: Declares value implements a type. Classes: ES6 classes, constructor functions. Property Modifiers: @public, @private, @protected, @readonly. @override: override methods. @extends, @implements: Class extension and interface implementation. @constructor: for constructor functions. @this: specify the type of this. @deprecated, @see, @link. @enum: Create an object literal with specified type. @author. Unsupported patterns and tags listed. JSX. Embeddable XML-like syntax transformed to JavaScript. Use .tsx extension and enable jsx option. JSX modes: preserve (keep JSX, .jsx output), react (React.createElement, .js output), react-native (keep JSX, .js output), react-jsx (_jsx, .js output), react-jsxdev (_jsxDEV, .js output). jsx option: "preserve"|"react"|"react-native"|"react-jsx"|"react-jsxdev". jsxFactory option for react JSX emit (default React.createElement). Use 'as' operator for type assertions in .tsx. Type checking: Intrinsic elements (lowercase, looked up in JSX.IntrinsicElements), Value-based elements (uppercase, custom components). JSX namespace: JSX, defined in different places depending on jsx option. Classic runtime (preserve, react, react-native): JSX namespace in scope (jsxFactory). Automatic runtime (react-jsx, react-jsxdev): JSX namespace exported from jsx-runtime.d.ts/jsx-dev-runtime.d.ts. IntrinsicElements interface in JSX namespace for intrinsic element type checking. Value-based elements: Function Component (FC, function, return JSX.Element), Class Component (class, instance type assignable to JSX.ElementClass). Element attributes type: from JSX.IntrinsicElements for intrinsics, from JSX.ElementAttributesProperty or constructor/FC parameter for value-based. Children type checking: JSX.ElementChildrenAttribute for children prop name. JSX result type: JSX.Element interface (default any). JSX function return type: JSX.Element | null by default, customizable with JSX.ElementType. Embedding expressions: {expression}. React integration: use React typings, define JSX namespace in react.d.ts. Configuring JSX: jsxFactory, jsxFragmentFactory, jsxImportSource compiler flags. Migrating from JavaScript. Use tsconfig.json to manage project options. Example: { "compilerOptions": { "outDir": "./built", "allowJs": true, "target": "es5" }, "include": ["./src/**/*"] }. tsc compiles src to built. Rename .js to .ts or .tsx. Use noEmitOnError to prevent compilation on errors. Use import foo = require("foo"); for CommonJS/AMD modules. npm install -S @types/lodash for declaration files. Use export function feedPets(pets) {} for module exports. Function overloads define multiple call signatures. interface Options { color: string; volume: number; }. Use any for flexible types, but lose type safety. Enable stricter checks like noImplicitAny, strictNullChecks, noImplicitThis. strictNullChecks: use number | null for nullable types. Postfix ! asserts non-null. Point.prototype.distanceFromOrigin = function (this: Point) { ... }; Mixins: Combine partial classes. Use generics with class inheritance. type Constructor = new (...args: any[]) => {}; function Scale<TBase extends Constructor>(Base: TBase) { return class Scaling extends Base { _scale = 1; setScale(scale: number) { this._scale = scale; } get scale(): number { return this._scale; } }; } ESM/CJS Interop: Transpiling challenges, Node.js issues. allowSyntheticDefaultImports: default imports for no default export. esModuleInterop: refined checks, __esModule emit. Node.js: no __esModule detect, unreliable named exports, no require ESM, diff resolution. module option critical. Apps: enable esModuleInterop. Avoid allowSyntheticDefaultImports alone. verbatimModuleSyntax better than no esModuleInterop. Libs (CJS): avoid default exports, use export =, named exports. Libs: validate .d.ts. verbatimModuleSyntax avoids esModuleInterop issues. TypeScript Modules: Introduction. Theory behind TypeScript modules. Compiler options, integration with other tools, dependency package processing. Guides for real-world tasks, compilation settings. Reference section for syntax and configurations. Appendices cover complicated topics. Modules: ECMAScript & CommonJS syntax supported. TypeScript extensions: export type, interface, enum, namespace. Type-only imports/exports: import type, export type. import() types: type T = import('mod').Type. export= and import=require() for CommonJS. Ambient modules: declare module 'mod' { ... }. Pattern ambient modules: declare module '*.ext' { ... }. Module compiler option: node16/nodenext: Node.js ESM/CJS, format detection, interoperability. preserve: Bundler/Bun, keeps import/export syntax, moduleResolution bundler. es2015/2020/2022/esnext: ES modules, not for Node.js. commonjs: CJS modules, dynamic import() transformed. system: SystemJS. amd: AMD loaders. umd: AMD/CJS loaders. ModuleResolution compiler option: Controls module specifier to file resolution. Common features: extension substitution, relative/extensionless paths, directory modules, paths, baseUrl, node_modules lookup. package.json exports, typesVersions, main, types, imports, self-name imports. node16/nodenext: Node.js resolution, import/require algorithms, exports/imports conditions (import/require). bundler: Bundler resolution, CommonJS + Node.js features, exports/imports conditions (syntax based). node10: Legacy Node.js resolution. classic: Deprecated. paths: Override module resolution for bare specifiers. baseUrl: Base directory for bare specifier resolution. package.json exports: Controls package subpath exports, conditions. package.json typesVersions: Version-specific type definitions. package.json main/types: Package entry points. Modules: Files with their own scope, providing code availability to other files. ESM (ECMAScript Modules): Built-in module system with import/export. CommonJS (CJS): Module system using exports and require. TypeScript's Job: Prevent runtime errors by compile-time checks. Know the runtime environment (globals). Answer questions related to module loading, resolution, and transformation. Module: Compiler option to control output module format and inform module kind detection. Options: node16, nodenext, es2015, es2020, es2022, esnext, commonjs, system, amd, umd. Node.js Module Format Detection (node16/nodenext): .mjs: ESM, .cjs: CJS, .js: ESM if package.json has "type": "module", otherwise CJS. Input Module Syntax: ESM syntax (import/export) is common regardless of output format. verbatimModuleSyntax (TS 5.0): Requires input syntax to match output format. ESM/CJS Interoperability: Varies between runtimes, bundlers, and transpilers. Node.js: CJS cannot synchronously require ESM. esModuleInterop option affects interop rules. Module Specifiers: Emitted as-written, not transformed by compiler. Module Resolution: Host-defined process of finding files referenced by module specifiers. moduleResolution option specifies host's algorithm. Options: classic, node10, node16, nodenext, bundler. Declaration Files (.d.ts): Describe JavaScript files, used for type information. Compiler looks for .d.ts files first, then .ts files. Module Resolution for Bundlers/TypeScript Runtimes: noEmit and allowImportingTsExtensions: Allow .ts extensions in imports. Use bundler moduleResolution. Module Resolution for Libraries: Use "module": "nodenext" for maximum compatibility. Namespaces: Organize code, avoid name collisions. namespace Validation { export interface StringValidator { isAcceptable(s: string): boolean; } export class LettersOnlyValidator implements StringValidator { isAcceptable(s: string) { return lettersRegexp.test(s); } } } Split across files using reference tags. Use outFile or per-file compilation. Aliases: import q = x.y.z. Ambient Namespaces: Declare APIs of external libraries. Modules: Organize code, better reuse, isolation, bundling. Recommended for new projects. Namespaces: TypeScript-specific, named JavaScript objects in global namespace. Can span multiple files. Pitfalls: Avoid /// <reference> for modules. Don't namespace module contents unnecessarily. TypeScript Nightly Builds: Install via npm: npm install -D typescript@next. VS Code: "typescript.tsdk": "/node_modules/typescript/lib". Sublime Text: "typescript_tsdk": "/node_modules/typescript/lib". VS 2013/2015: Use VSDevMode.ps1. IntelliJ IDEA: Configure TypeScript Version. Project References: Allows structuring TypeScript programs into smaller parts. `references`: Array of objects specifying referenced projects. `composite`: Must be enabled for referenced projects. `declaration`: Must be turned on for composite. `declarationMap`: Enables editor features across project boundaries. Build Mode: `tsc --build` builds referenced projects if needed. Flags: `--verbose`, `--dry`, `--clean`, `--force`, `--watch`. Caveats: Requires build outputs checked in or built before editor navigation. Symbols: Primitive type for unique identifiers. Symbol(): creates unique symbol. Optional string key for description. Symbols are unique and immutable. Used as object property keys. unique symbol: subtype of symbol. Well-known Symbols: Built-in symbols for language behaviors. Symbol.asyncIterator, Symbol.hasInstance, Symbol.isConcatSpreadable, Symbol.iterator, Symbol.match, Symbol.replace, Symbol.search, Symbol.species, Symbol.split, Symbol.toPrimitive, Symbol.toStringTag, Symbol.unscopables. /// <reference path="..." /> declares file dependencies. /// <reference types="..." /> declares package dependencies. /// <reference lib="..." /> includes built-in lib file. /// <reference no-default-lib="true"/> excludes default lib. /// <amd-module name="..."/> defines AMD module name. /// <amd-dependency path="..."/> injects non-TS module dependency. preserve="true" prevents compiler removal. TSConfig Reference: Configuration for TypeScript projects. compilerOptions: Type Checking: allowUnreachableCode: Controls unreachable code errors. Options: true (ignore), false (error), undefined (warn). allowUnusedLabels: Controls unused label errors. Options: true (ignore), false (error), undefined (warn). alwaysStrict: Ensures ECMAScript strict mode. exactOptionalPropertyTypes: Stricter rules for optional properties. noFallthroughCasesInSwitch: Switch statement fallthrough errors. noImplicitAny: Implicit any type errors. noImplicitOverride: Missing override keyword errors in subclasses. noImplicitReturns: Function return path errors. noImplicitThis: 'this' expression errors with implied 'any'. noPropertyAccessFromIndexSignature: Dot syntax access error for index signature properties. noUncheckedIndexedAccess: Adds undefined to un-declared fields in index signatures. noUnusedLocals: Unused local variable errors. noUnusedParameters: Unused parameter errors. strict: Enables all strict type checking options. strictBindCallApply: Checks function.call, bind, apply arguments. strictBuiltinIteratorReturn: Built-in iterator TReturn type is undefined. strictFunctionTypes: Stricter function parameter checking. strictNullChecks: Null and undefined type checking. strictPropertyInitialization: Class property initialization in constructor errors. useUnknownInCatchVariables: Catch variable type is unknown. Modules: allowArbitraryExtensions: Allows import paths with non-JS/TS extensions. allowImportingTsExtensions: Allows TS extension imports in TS files (noEmit/emitDeclarationOnly). allowUmdGlobalAccess: Access UMD exports as globals in modules. baseUrl: Base directory for bare specifier module resolution. customConditions: Additional conditions for package.json exports/imports. module: Sets module system. Allowed: none, commonjs, amd, umd, system, es6/2015, es2020, es2022, esnext, node16, nodenext, preserve. moduleResolution: Module resolution strategy. Allowed: classic, node10/node, node16, nodenext, bundler. moduleSuffixes: Overrides default file name suffixes for module resolution. noResolve: Disables resolving imports/references. noUncheckedSideEffectImports: Errors on unresolved side effect imports. paths: Re-maps imports to lookup locations. resolveJsonModule: Allows importing .json modules. resolvePackageJsonExports: Consults package.json exports field. resolvePackageJsonImports: Consults package.json imports field. rootDir: Root directory for output directory structure. rootDirs: Virtual directories as a single root. typeRoots: Specifies type definition directories. types: Specifies type definition packages. Emit: declaration: Generates .d.ts files. declarationDir: Root directory for .d.ts files. declarationMap: Generates source maps for .d.ts files. downlevelIteration: Accurate iteration for older JS runtimes. emitBOM: Emits byte order mark (BOM) in output files. emitDeclarationOnly: Only emit .d.ts files. importHelpers: Imports helper functions from tslib module. inlineSourceMap: Embeds source map content in .js files. inlineSources: Embeds .ts file content in source map. mapRoot: Location for debugger to find map files. newLine: End of line sequence for output files (crlf/lf). noEmit: Do not emit output files. noEmitHelpers: Do not emit helper functions. noEmitOnError: Do not emit files on errors. outDir: Output directory for .js files. outFile: Single output .js file for global/AMD/System modules. preserveConstEnums: Do not erase const enum declarations. removeComments: Strips comments from .js files. sourceMap: Generates sourcemap files. sourceRoot: Location for debugger to find .ts files. stripInternal: Do not emit declarations for @internal code. JavaScript Support: allowJs: Allows importing JavaScript files. checkJs: Reports errors in JavaScript files. maxNodeModuleJsDepth: Maximum dependency depth for JavaScript files in node_modules. Editor Support: disableSizeLimit: Removes memory size limit for large projects. plugins: List of language service plugins. Interop Constraints: allowSyntheticDefaultImports: Allows default imports from modules without default exports. esModuleInterop: Fixes CommonJS/AMD/UMD module interop issues. forceConsistentCasingInFileNames: Enforces consistent file casing. isolatedDeclarations: Requires annotation for declaration file generation. isolatedModules: Warns for code incompatible with single-file transpilation. preserveSymlinks: Preserves symlinks in module/package resolution. verbatimModuleSyntax: Simplifies module syntax handling, deprecated: importsNotUsedAsValues, preserveValueImports. Backwards Compatibility: charset: Deprecated, assumed UTF-8. importsNotUsedAsValues: Deprecated, use verbatimModuleSyntax. keyofStringsOnly: keyof operator returns string instead of string|number. noImplicitUseStrict: Disables "use strict" prologue. noStrictGenericChecks: Disables generic function type parameter unification. out: Deprecated, use outFile. preserveValueImports: Deprecated, use verbatimModuleSyntax. suppressExcessPropertyErrors: Disables excess property errors. suppressImplicitAnyIndexErrors: Disables implicit any index errors. Language and Environment: emitDecoratorMetadata: Emits type metadata for decorators. experimentalDecorators: Enables experimental decorator support. jsx: JSX output mode (preserve, react, react-native, react-jsx, react-jsxdev). jsxFactory: JSX factory function. jsxFragmentFactory: JSX fragment factory function. jsxImportSource: JSX import source module specifier. lib: Specifies library files to include. moduleDetection: Controls module/script file detection. noLib: Disables automatic inclusion of library files. reactNamespace: Deprecated, use jsxFactory. target: ECMAScript target version. useDefineForClassFields: Uses standard class fields runtime behavior. Compiler Diagnostics: diagnostics: Outputs diagnostic information. explainFiles: Prints files in compilation and reasons. extendedDiagnostics: Detailed performance diagnostics. generateCpuProfile: Generates v8 CPU profile. generateTrace: Generates event trace and type list. listEmittedFiles: Prints emitted file names. listFiles: Prints files in compilation. noCheck: Disables full type checking. traceResolution: Prints module resolution information. Projects: composite: Enables composite project mode. disableReferencedProjectLoad: Disables automatic project loading. disableSolutionSearching: Disables project inclusion in solution searches. disableSourceOfProjectReferenceRedirect: Reverts to pre-3.7 project reference behavior. incremental: Enables incremental compilation. tsBuildInfoFile: Specifies file for incremental compilation info. Output Formatting: noErrorTruncation: Do not truncate error messages. preserveWatchOutput: Keeps outdated console output in watch mode. pretty: Stylizes errors and messages (default true). Completeness: skipDefaultLibCheck: Deprecated, use skipLibCheck. skipLibCheck: Skips type checking of declaration files. Command Line Watch Options: assumeChangesOnlyAffectDirectDependencies: Fast watch mode, rebuilds direct dependencies only. watchOptions: Watch file options. watchFile: Strategy for watching individual files. watchDirectory: Strategy for watching directory trees. fallbackPolling: Polling strategy when file system events fail. synchronousWatchDirectory: Synchronous directory watcher callbacks. excludeDirectories: Excludes directories from watch. excludeFiles: Excludes files from watch. Type Acquisition: enable: Disables automatic type acquisition. include: Specifies types to include from DefinitelyTyped. exclude: Excludes modules from type acquisition. disableFilenameBasedTypeAcquisition: Disables filename-based type acquisition. TSConfig Reference: `files`: Array of files to include. `extends`: Path to another config file to inherit from. `include`: Array of filenames or patterns to include. `exclude`: Array of filenames or patterns to exclude. `references`: Project references. Compiler Options: `allowUnreachableCode`: Handle unreachable code. `allowUnusedLabels`: Handle unused labels. `alwaysStrict`: Ensure ECMAScript strict mode. `exactOptionalPropertyTypes`: Stricter rules for optional properties. `noFallthroughCasesInSwitch`: Report fallthrough cases. `noImplicitAny`: Error on implicit any. `noImplicitOverride`: Require `override` keyword. `noImplicitReturns`: Check all code paths return a value. `noImplicitThis`: Error on 'this' with implied 'any' type. `noPropertyAccessFromIndexSignature`: Consistency between dot and indexed syntax. `noUncheckedIndexedAccess`: Add undefined to undeclared fields. `noUnusedLocals`: Report unused local variables. `noUnusedParameters`: Report unused parameters. `strict`: Enable strict mode family. `strictBindCallApply`: Check call, bind, and apply arguments. `strictBuiltinIteratorReturn`: Built-in iterators with `undefined` return type. `strictFunctionTypes`: More correct function parameter checks. `strictNullChecks`: Handle null and undefined more strictly. `strictPropertyInitialization`: Error on uninitialized class properties. `useUnknownInCatchVariables`: Use unknown type in catch variables. Modules: `allowArbitraryExtensions`: Allow arbitrary file extensions in imports. `allowImportingTsExtensions`: Allow TypeScript files to import each other with a TypeScript-specific extension like .ts, .mts, or .tsx. `allowUmdGlobalAccess`: Allow UMD exports as globals. `baseUrl`: Base directory for module resolution. `customConditions`: Custom conditions for module resolution. `module`: Module system for the program. `moduleResolution`: Module resolution strategy. `moduleSuffixes`: Override default file name suffixes. `noResolve`: Disable resolving import and reference directives. `noUncheckedSideEffectImports`: Error on side effect imports. `paths`: Remap imports. `resolveJsonModule`: Import JSON modules. `resolvePackageJsonExports`: Consult package.json exports. `resolvePackageJsonImports`: Consult package.json imports. `rootDir`: Root directory. `rootDirs`: Virtual directories as a single root. `typeRoots`: Directories for type definitions. `types`: Packages to include in global scope. Emit: `declaration`: Generate .d.ts files. `declarationDir`: Root directory for declaration files. `declarationMap`: Generate source maps for .d.ts files. `downlevelIteration`: Support modern iteration primitives in older JS. `emitBOM`: Emit byte order mark. `emitDeclarationOnly`: Only emit .d.ts files. `importHelpers`: Import helper functions from tslib. `inlineSourceMap`: Embed source map content in .js files. `inlineSources`: Include original content of .ts file in source map. `mapRoot`: Specify location for debugger to find map files. `newLine`: End of line sequence. `noEmit`: Do not emit output files. `noEmitHelpers`: Do not emit helper functions. `noEmitOnError`: Do not emit if errors are reported. `outDir`: Output directory for .js files. `outFile`: Concatenate output into a single file. `preserveConstEnums`: Do not erase const enum declarations. `removeComments`: Strip comments from output. `sourceMap`: Generate source map files. `sourceRoot`: Specify the location of TypeScript files. `stripInternal`: Do not emit declarations for @internal code. JavaScript Support: `allowJs`: Allow JavaScript files. `checkJs`: Report errors in JavaScript files. `maxNodeModuleJsDepth`: Max dependency depth to search for JS files. Editor Support: `disableSizeLimit`: Disable memory limit. `plugins`: List of language service plugins. Interop Constraints: `allowSyntheticDefaultImports`: Allow `import React from "react"` when there is no default export. `esModuleInterop`: Fixes CommonJS/AMD/UMD module interop issues. `forceConsistentCasingInFileNames`: Enforce consistent casing. `isolatedDeclarations`: Require annotation on exports. `isolatedModules`: Warn about code not correctly interpreted by single-file transpilation. `preserveSymlinks`: Reflect Node.js symlink behavior. `verbatimModuleSyntax`: Preserve imports and exports without the type modifier. Backwards Compatibility: `charset`: Encoding for text files. `importsNotUsedAsValues`: Controls how imports work, with options of remove, preserve or error. `keyofStringsOnly`: keyof type operator to return string instead of string | number. `noImplicitUseStrict`: Disable "use strict" prologue. `noStrictGenericChecks`: Remove generic checks. `out`: Use outFile instead. `preserveValueImports`: Prevent some module elision behavior. `suppressExcessPropertyErrors`: Disable excess property errors. `suppressImplicitAnyIndexErrors`: Suppress implicit any index errors. Language and Environment: `emitDecoratorMetadata`: Emit metadata for decorators. `experimentalDecorators`: Enable experimental decorators. `jsx`: Control JSX emission. `jsxFactory`: JSX factory function. `jsxFragmentFactory`: JSX fragment factory function. `jsxImportSource`: Module specifier for importing jsx and jsxs factory functions. `lib`: Include default type definitions. `moduleDetection`: Determines if a file is a script or a module. `noLib`: Disable automatic inclusion of library files. `reactNamespace`: Specify object invoked for createElement when targeting react for TSX files. `target`: Target JavaScript version. `useDefineForClassFields`: Use define for class fields. Compiler Diagnostics: `diagnostics`: Output diagnostic information. `explainFiles`: Print names of files and reasons for compilation. `extendedDiagnostics`: Output extended diagnostic information. `generateCpuProfile`: Emit CPU profile. `generateTrace`: Generates an event trace and a list of types. `listEmittedFiles`: Print generated files. `listFiles`: Print names of files. `noCheck`: Disable full type checking. `traceResolution`: Print information about module resolution. Projects: `composite`: Enable composite project. `disableReferencedProjectLoad`: Disable loading of referenced projects. `disableSolutionSearching`: Disable project searching. `disableSourceOfProjectReferenceRedirect`: Go back to pre-3.7 behavior. `incremental`: Save project graph information. `tsBuildInfoFile`: Specify a file for storing incremental compilation information. Output Formatting: `noErrorTruncation`: Do not truncate error messages. `preserveWatchOutput`: Keep outdated console output. `pretty`: Stylize errors and messages. Completeness: `skipDefaultLibCheck`: Skip type checking of default library declaration files. `skipLibCheck`: Skip type checking of declaration files. Command Line Watch Options: `assumeChangesOnlyAffectDirectDependencies`: Assume changes affect only direct dependencies. Watch Options: `watchFile`: Strategy for watching individual files. `watchDirectory`: Strategy for watching directory trees. `fallbackPolling`: Polling strategy when system runs out of native watchers. `synchronousWatchDirectory`: Synchronously call callbacks. `excludeDirectories`: Directories to exclude. `excludeFiles`: Files to exclude. Type Acquisition: `enable`: Enable automatic type acquisition. `include`: Types to include. `exclude`: Types to exclude. `disableFilenameBasedTypeAcquisition`: Disable filename-based type acquisition. tsconfig.json: Specifies project root files and compiler options. Can use files, include/exclude properties. Compiler options include module, noImplicitAny, removeComments, preserveConstEnums, sourceMap, outFile. Extends other tsconfig.json files via the extends property. JavaScript file type checking differences: Properties: Inferred from assignments inside class. If not in constructor, it's optional. Constructor functions: Equivalent to ES2015 classes. Modules: CommonJS modules supported. Namespaces: Classes, functions, object literals can be namespaces. Object literals: Open-ended type ([x:string]: any). null, undefined, []: Type any or any[]. Function parameters: Optional by default. Var-args parameter: inferred from arguments reference. Type parameters: Unspecified defaults to any. JSDoc: Use for type annotations. Type Compatibility: Based on structural subtyping (members). x compatible with y if y has at least same members as x. Function Compatibility: Parameter lists: x assignable to y if x's parameters have compatible types in y. Return Types: Source function's return type must be subtype of target's. Optional Parameters and Rest Parameters: Interchangeable. Rest parameters treated as infinite series of optional parameters. Functions with overloads: Target overloads must have compatible source signatures. Enums: Compatible with numbers. Classes: Instance members compared. Static members and constructors do not affect compatibility. Private/protected members affect compatibility; must originate from same class. Generics: Type parameters affect resulting type if used in member's type. Type Inference: Used when no explicit type annotation is present. let x = 3; // x is inferred as number. Best common type: Calculates a "best common type" from several expressions. let x = [0, 1, null]; // infers type of x. Contextual Typing: Type of expression implied by its location. window.onmousedown = function (mouseEvent) { ... }; // infers mouseEvent type. No best common type results in union array type. Explicitly provide type to correct: let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()]; TypeScript: Static type checker and typed superset of JavaScript. Syntax: JS syntax is legal TS. Type checking: Detects errors before execution based on value types. Runtime behavior: Preserves JS runtime behavior. Erased types: Types are removed after compilation, no runtime impact. No additional runtime libraries. TypeScript: Superset of JavaScript with static typing. Types: inferred or explicitly defined (interfaces, types). Primitive types: boolean, bigint, null, number, string, symbol, undefined, any, unknown, never, void. Unions: type can be one of many types (e.g., type MyBool = true | false;). Generics: type variables for types (e.g., Array). Structural Type System: type checking based on shape, not declaration (duck typing). Built-in types: number, string, bigint, boolean, symbol, null, undefined, object. Other important TypeScript types: unknown, never, object, void, T[], [T, T], (T: T) => U. Structural typing: let o2: { x: string } = o; Unions: function start( arg: string | string[] | (() => string) | { s: string } ): string Intersections: type Combined = { a: number } & { b: string }; Unit types: declare function pad(s: string, n: number, direction: "left" | "right"): string; Contextual typing: let sns = map((n) => n.toString(), [1, 2, 3]); Type aliases: type Size = [number, number]; Discriminated Unions: type Shape = | { kind: "circle"; radius: number } | { kind: "square"; x: number } | { kind: "triangle"; x: number; y: number }; function area(s: Shape) returns number Type Parameters: function liftArray(t: T): Array readonly and const: interface Rx { readonly x: number; } TypeScript for Java/C# Programmers: TypeScript provides static typing benefits. JavaScript differs from traditional OOP languages. Rethinking the Class: JavaScript functions can exist outside classes. Static classes are unnecessary. OOP in TypeScript: Classes, interfaces, inheritance, and static methods are supported. Rethinking Types: TypeScript types differ from C# or Java. Nominal Reified Type Systems: C#/Java have exact runtime types. Types as Sets: TypeScript types are sets of values. Erased Structural Types: Type relationships are based on properties, not declarations. interface Pointlike { x: number; y: number; } function logPoint(point: Pointlike) { console.log(point.x) } logPoint({ x: 0, y: 0, name: "Origin" }); Consequences of Structural Typing: Empty types and identical types. Reflection: TypeScript's type system is erased at runtime. TypeScript Tooling: Install: npm install -g typescript. Compile: tsc greeter.ts. Type Annotations: function greeter(person: string): string. Interfaces: interface Person { firstName: string; lastName: string; }. Classes: class Student { constructor(public firstName: string, public lastName: string) {} }. Example: let user = new Student("Jane", "User"); Awaited<Type> unwraps Promises. Partial<Type> sets all props of Type to optional. Required<Type> sets all props to required. Readonly<Type> sets all props to readonly. Record<Keys, Type> creates an object with keys from Keys and values from Type. Pick<Type, Keys> picks props from Type. Omit<Type, Keys> omits props from Type. Exclude<UnionType, ExcludedMembers> excludes members. Extract<Type, Union> extracts members. NonNullable<Type> excludes null and undefined. Parameters<Type> creates a tuple from function parameters. ConstructorParameters<Type> creates a tuple from constructor parameters. ReturnType<Type> gets function's return type. InstanceType<Type> gets instance type of a constructor. NoInfer<Type> blocks type inference. ThisParameterType<Type> extracts this parameter type. OmitThisParameter<Type> removes this parameter. ThisType<Type> is a marker for contextual 'this' type. String manipulation types: Uppercase<StringType>, Lowercase<StringType>, Capitalize<StringType>, Uncapitalize<StringType>. let: block-scoped variable declaration. const: block-scoped, read-only variable declaration. Destructuring: extract values from arrays/objects into variables. Array destructuring: let [first, ...rest] = [1, 2, 3, 4]; Object destructuring: let { a, ...passthrough } = o; Spread: expand array/object. using: resource management, calls [Symbol.dispose] on scope exit. await using: async resource management, calls [Symbol.asyncDispose]. Disposable interface: [Symbol.dispose](): void; AsyncDisposable interface: [Symbol.asyncDispose]: PromiseLike<void>; Why TypeScript?: TypeScript extends JavaScript, adds types for scalability. JavaScript for web interactivity (front-end): HTML (content), CSS (style), JS (behavior). Programming languages: Human-computer communication. JavaScript: Scripting language, dynamic types. Java: Statically typed, more verbose. TypeScript: Static typing to JavaScript, catches errors early, improves code maintainability in large projects. Types enhance code confidence and reduce debugging time.
